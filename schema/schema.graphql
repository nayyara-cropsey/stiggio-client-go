type BaseError {
  code: String!
}

type EntitlementLimitExceededError {
  code: String!
  isValidationError: Boolean!
  feature: String!
}

type Auth0ApplicationDTO {
  appId: String!
  name: String!
  type: Auth0ApplicationType
}

"""Auth0 application type."""
enum Auth0ApplicationType {
  INDIVIDUAL
  ORGANIZATION
  BOTH
}

type DuplicatedEntityNotAllowedError {
  code: String!
  isValidationError: Boolean!
  identifier: String!
  entityName: String!
}

"""access roles"""
type AccessRoles {
  """Account level access of the user"""
  accountRole: AccountAccessRole!

  """Production environment level access of the user"""
  productionRole: EnvironmentAccessRole!

  """Non-production environment level access of the user"""
  nonProductionRole: EnvironmentAccessRole!
}

"""Account access role of the user"""
enum AccountAccessRole {
  OWNER
  MEMBER
}

"""Environment access role of the user"""
enum EnvironmentAccessRole {
  ADMIN
  VIEWER
  SUPPORT
  NONE
}

type Account {
  id: String!
  displayName: String!
  timezone: String
  subscriptionBillingAnchor: BillingAnchor
  subscriptionProrationBehavior: ProrationBehavior
  accountStatus: AccountStatus
  accountEmailDomain: String
  samlEnabled: Boolean
  defaultSSORoles: AccessRoles
}

enum BillingAnchor {
  SUBSCRIPTION_START
  START_OF_THE_MONTH
  SUBSCRIPTIONS_CONSOLIDATE_BILLING
}

enum ProrationBehavior {
  INVOICE_IMMEDIATELY
  CREATE_PRORATIONS
}

enum AccountStatus {
  BLOCKED
  ACTIVE
}

type IdentityForbiddenError {
  code: String!
  isValidationError: Boolean!
  currentIdentityType: String!
  requiredIdentityType: String!
  accessedField: String!
}

type ApiKey {
  id: String!
  keyType: ApiKeyType!
  token: String!
}

enum ApiKeyType {
  SERVER
  CLIENT
  SALESFORCE
}

type EnvironmentMissingError {
  code: String!
  isValidationError: Boolean!
}

type InvalidArgumentError {
  code: String!
  isValidationError: Boolean!
}

"""An environment object"""
type Environment {
  id: String!
  createdAt: DateTime
  displayName: String!
  description: String
  slug: String!
  provisionStatus: EnvironmentProvisionStatus
  type: EnvironmentType!
  signingToken: String!
  hardenClientAccessEnabled: Boolean!
  isSandbox: Boolean!
  color: String
  permanentDeletionDate: DateTime
  account: Account
  apiKeys(
    """Specify to filter the records returned."""
    filter: ApiKeyFilter = {}

    """Specify to sort results."""
    sorting: [ApiKeySort!] = []
  ): [ApiKey!]!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""EnvironmentProvisionStatus."""
enum EnvironmentProvisionStatus {
  NOT_PROVISIONED
  IN_PROGRESS
  FAILED
  DONE
}

"""EnvironmentType."""
enum EnvironmentType {
  PRODUCTION
  DEVELOPMENT
  SANDBOX
}

input ApiKeyFilter {
  and: [ApiKeyFilter!]
  or: [ApiKeyFilter!]
  id: StringFieldComparison
}

input StringFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: String
  neq: String
  gt: String
  gte: String
  lt: String
  lte: String
  like: String
  notLike: String
  iLike: String
  notILike: String
  in: [String!]
  notIn: [String!]
}

input ApiKeySort {
  field: ApiKeySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ApiKeySortFields {
  id
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

"""Transformation to the reported usage"""
type UnitTransformation {
  """After division, either round the result up or down"""
  round: UnitTransformationRound!

  """Divide usage by this number"""
  divide: Float!

  """Singular feature units after the transformation"""
  featureUnits: String

  """Plural feature units after the transformation"""
  featureUnitsPlural: String
}

"""Unit transformation round type"""
enum UnitTransformationRound {
  """Apply round up after transformation"""
  UP

  """Apply round down after transformation"""
  DOWN
}

type Feature {
  id: String!
  displayName: String!
  refId: String!
  createdAt: DateTime
  updatedAt: DateTime!
  featureUnits: String
  featureUnitsPlural: String
  description: String
  featureType: FeatureType!
  meterType: MeterType
  featureStatus: FeatureStatus!
  environmentId: String!
  additionalMetaData: JSON

  """Unit transformation to be applied to the reported usage"""
  unitTransformation: UnitTransformation
  hasMeter: Boolean
  hasEntitlements: Boolean
  meter: Meter
  account: Account
  environment: Environment
}

"""The type of the feature"""
enum FeatureType {
  BOOLEAN
  NUMBER
}

"""The meter type of the feature"""
enum MeterType {
  None
  Fluctuating
  Incremental
}

"""Feature status."""
enum FeatureStatus {
  NEW
  SUSPENDED
  ACTIVE
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type PlanNotFoundError {
  code: String!
  isValidationError: Boolean!
  refId: String!
}

type Aggregation {
  function: AggregationFunction!
  field: String
}

"""Aggregation function"""
enum AggregationFunction {
  SUM
  MAX
  MIN
  AVG
  COUNT
  UNIQUE
}

type MeterCondition {
  field: String!
  operation: ConditionOperation!
  value: String
}

"""Condition operation"""
enum ConditionOperation {
  EQUALS
  NOT_EQUALS
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN
  LESS_THAN_OR_EQUAL
  IS_NULL
  IS_NOT_NULL
}

type MeterFilterDefinition {
  conditions: [MeterCondition!]!
}

type Meter {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  aggregation: Aggregation!
  filters: [MeterFilterDefinition!]!
  environmentId: String!
}

type PackageEntitlement {
  id: String!
  description: String
  featureId: String!
  packageId: String!
  createdAt: DateTime
  updatedAt: DateTime
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  isCustom: Boolean
  environmentId: String!
  resetPeriod: EntitlementResetPeriod
  resetPeriodConfiguration: ResetPeriodConfiguration
  order: Float
  hiddenFromWidgets: [WidgetType!]
  displayNameOverride: String

  """The behavior of the entitlement"""
  behavior: EntitlementBehavior!
  feature: Feature!
  package: PackageDTO
  meter: Meter
}

"""Entitlement reset period."""
enum EntitlementResetPeriod {
  YEAR
  MONTH
  WEEK
  DAY
  HOUR
}

union ResetPeriodConfiguration = YearlyResetPeriodConfig | MonthlyResetPeriodConfig | WeeklyResetPeriodConfig

type YearlyResetPeriodConfig {
  yearlyAccordingTo: YearlyAccordingTo
}

"""Yearly reset period according to configuration"""
enum YearlyAccordingTo {
  SubscriptionStart
}

type MonthlyResetPeriodConfig {
  monthlyAccordingTo: MonthlyAccordingTo
}

"""Monthly reset period according to configuration"""
enum MonthlyAccordingTo {
  SubscriptionStart
  StartOfTheMonth
}

type WeeklyResetPeriodConfig {
  weeklyAccordingTo: WeeklyAccordingTo
}

"""Weekly reset period according to configuration"""
enum WeeklyAccordingTo {
  SubscriptionStart
  EverySunday
  EveryMonday
  EveryTuesday
  EveryWednesday
  EveryThursday
  EveryFriday
  EverySaturday
}

"""The widget type"""
enum WidgetType {
  PAYWALL
  CUSTOMER_PORTAL
  CHECKOUT
}

"""The behavior of the entitlement"""
enum EntitlementBehavior {
  """Increment the value of the entitlement"""
  Increment

  """Override the value of the entitlement"""
  Override
}

type Money {
  amount: Float!
  currency: Currency!
}

"""Currency"""
enum Currency {
  USD
  AED
  ALL
  AMD
  ANG
  AUD
  AWG
  AZN
  BAM
  BBD
  BDT
  BGN
  BIF
  BMD
  BND
  BSD
  BWP
  BYN
  BZD
  CAD
  CDF
  CHF
  CNY
  CZK
  DKK
  DOP
  DZD
  EGP
  ETB
  EUR
  FJD
  GBP
  GEL
  GIP
  GMD
  GYD
  HKD
  HRK
  HTG
  IDR
  ILS
  INR
  ISK
  JMD
  JPY
  KES
  KGS
  KHR
  KMF
  KRW
  KYD
  KZT
  LBP
  LKR
  LRD
  LSL
  MAD
  MDL
  MGA
  MKD
  MMK
  MNT
  MOP
  MRO
  MVR
  MWK
  MXN
  MYR
  MZN
  NAD
  NGN
  NOK
  NPR
  NZD
  PGK
  PHP
  PKR
  PLN
  QAR
  RON
  RSD
  RUB
  RWF
  SAR
  SBD
  SCR
  SEK
  SGD
  SLE
  SLL
  SOS
  SZL
  THB
  TJS
  TOP
  TRY
  TTD
  TZS
  UAH
  UZS
  VND
  VUV
  WST
  XAF
  XCD
  YER
  ZAR
  ZMW
  CLP
  DJF
  GNF
  UGX
  PYG
  XOF
  XPF
}

type PriceTier {
  upTo: Float
  unitPrice: Money
  flatPrice: Money
}

type Price {
  id: String!
  createdAt: DateTime
  environmentId: String
  billingPeriod: BillingPeriod!
  billingModel: BillingModel!
  billingCadence: BillingCadence!
  tiersMode: TiersMode
  tiers: [PriceTier!]
  billingId: String
  price: Money

  """The number of units per block. Defaults to 1 unit."""
  blockSize: Float
  billingCountryCode: String
  featureId: String
  minUnitQuantity: Float
  packageId: String
  maxUnitQuantity: Float
  feature: Feature
  crmId: String
  crmLinkUrl: String
  usedInSubscriptions: Boolean
  resetPeriod: EntitlementResetPeriod
  resetPeriodConfiguration: ResetPeriodConfiguration

  """Indication whether the subscription price is an override price"""
  isOverridePrice: Boolean!
  package: PackageDTO!
}

"""Billing period."""
enum BillingPeriod {
  MONTHLY
  ANNUALLY
}

"""Billing model."""
enum BillingModel {
  FLAT_FEE
  MINIMUM_SPEND
  PER_UNIT
  USAGE_BASED
}

"""Billing Cadence."""
enum BillingCadence {
  RECURRING
  ONE_OFF
}

"""Tiers mode."""
enum TiersMode {
  VOLUME
  GRADUATED
}

"""Budget configuration"""
type BudgetConfiguration {
  """The maximum spending limit"""
  limit: Float!

  """
  Indicates the behavior of the budget when the limit is exceeded. If true, the limit is a soft limit, if false, the limit is a hard limit. Default is false.
  """
  hasSoftLimit: Boolean!
}

type DefaultTrialConfig {
  units: TrialPeriodUnits!
  duration: Float!

  """Budget configuration"""
  budget: BudgetConfiguration

  """Trial end behavior"""
  trialEndBehavior: TrialEndBehavior
}

"""day or month."""
enum TrialPeriodUnits {
  DAY
  MONTH
}

"""Indicates the behavior of the subscription when the trial is expired."""
enum TrialEndBehavior {
  """convert the trial subscription to a paid subscription"""
  CONVERT_TO_PAID

  """cancel the subscription when the trial is expired"""
  CANCEL_SUBSCRIPTION
}

type ProductSettings {
  subscriptionEndSetup: SubscriptionEndSetup!
  subscriptionCancellationTime: SubscriptionCancellationTime!
  downgradePlan: Plan
  downgradePlanId: String
  subscriptionStartSetup: SubscriptionStartSetup!
  subscriptionStartPlan: Plan
  subscriptionStartPlanId: String
  prorateAtEndOfBillingPeriod: Boolean
}

""""""
enum SubscriptionEndSetup {
  DOWNGRADE_TO_FREE
  CANCEL_SUBSCRIPTION
}

""""""
enum SubscriptionCancellationTime {
  END_OF_BILLING_PERIOD
  IMMEDIATE
  SPECIFIC_DATE
}

""""""
enum SubscriptionStartSetup {
  PLAN_SELECTION
  TRIAL_PERIOD
  FREE_PLAN
}

"""
Auto cancellation rule - when subscription for source plan is canceled, other subscriptions to target plan would be cancelled as well
"""
type AutoCancellationRule {
  """The source plan."""
  sourcePlan: Plan!

  """The target plan."""
  targetPlan: Plan!
}

"""
Usage reset cutoff rule - when does the usage for a feature should be reset
"""
type SubscriptionUpdateUsageResetCutoffRule {
  """The behavior to reset according to"""
  behavior: SubscriptionUpdateUsageCutoffBehavior!
}

"""
Decide whether feature usage will be reset upon creation on new subscription
"""
enum SubscriptionUpdateUsageCutoffBehavior {
  """Never reset"""
  NEVER_RESET

  """Always reset"""
  ALWAYS_RESET

  """Billing period changed"""
  BILLING_PERIOD_CHANGE
}

"""A product object"""
type Product {
  id: String!
  displayName: String
  refId: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  environmentId: String!
  isDefaultProduct: Boolean!
  plans: [Plan!]!
  addons: [Addon!]!
  productSettings: ProductSettings!
  multipleSubscriptions: Boolean!
  additionalMetaData: JSON
  awsMarketplaceProductId: String
  awsMarketplaceProductCode: String
  autoCancellationRules: [AutoCancellationRule!]!
  subscriptionUpdateUsageResetCutoffRule: SubscriptionUpdateUsageResetCutoffRule!
  hasSubscriptions: Boolean!
  environment: Environment
  downgradePlan: Plan
  subscriptionStartPlan: Plan
}

"""Package group"""
type PackageGroup {
  """The display name of the package group"""
  displayName: String!

  """The description of the package group"""
  description: String

  """The id of the package group"""
  packageGroupId: String!

  """The date the package group was created"""
  createdAt: DateTime!

  """The date the package group was last updated"""
  updatedAt: DateTime!

  """The environment id of the package group in"""
  environmentId: String!

  """Indicates if this is the latest version of the package group"""
  isLatest: Boolean!

  """The version number of the package group"""
  versionNumber: Int!

  """The status of the package group"""
  status: PackageGroupStatus!
  productId: String
  product: Product!
  addons(
    """Specify to filter the records returned."""
    filter: AddonFilter = {}

    """Specify to sort results."""
    sorting: [AddonSort!] = [{field: createdAt, direction: DESC}]
  ): [Addon!]
}

"""Package group status."""
enum PackageGroupStatus {
  """The package group is a draft."""
  DRAFT

  """The package group is published."""
  PUBLISHED

  """The package group is archived."""
  ARCHIVED
}

input AddonFilter {
  and: [AddonFilter!]
  or: [AddonFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  refId: StringFieldComparison
  billingId: StringFieldComparison
  displayName: StringFieldComparison
  status: PackageStatusFilterComparison
  pricingType: PricingTypeFilterComparison
  description: StringFieldComparison
  environmentId: StringFieldComparison
  productId: StringFieldComparison
  isLatest: BooleanFieldComparison
  versionNumber: IntFieldComparison
}

input DateFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: DateTime
  neq: DateTime
  gt: DateTime
  gte: DateTime
  lt: DateTime
  lte: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  between: DateFieldComparisonBetween
  notBetween: DateFieldComparisonBetween
}

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

input PackageStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PackageStatus
  neq: PackageStatus
  gt: PackageStatus
  gte: PackageStatus
  lt: PackageStatus
  lte: PackageStatus
  like: PackageStatus
  notLike: PackageStatus
  iLike: PackageStatus
  notILike: PackageStatus
  in: [PackageStatus!]
  notIn: [PackageStatus!]
}

"""Package status."""
enum PackageStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

input PricingTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PricingType
  neq: PricingType
  gt: PricingType
  gte: PricingType
  lt: PricingType
  lte: PricingType
  like: PricingType
  notLike: PricingType
  iLike: PricingType
  notILike: PricingType
  in: [PricingType!]
  notIn: [PricingType!]
}

"""Pricing Type."""
enum PricingType {
  FREE
  PAID
  CUSTOM
}

input BooleanFieldComparison {
  is: Boolean
  isNot: Boolean
}

input IntFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: Int
  neq: Int
  gt: Int
  gte: Int
  lt: Int
  lte: Int
  in: [Int!]
  notIn: [Int!]
  between: IntFieldComparisonBetween
  notBetween: IntFieldComparisonBetween
}

input IntFieldComparisonBetween {
  lower: Int!
  upper: Int!
}

input AddonSort {
  field: AddonSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum AddonSortFields {
  id
  createdAt
  updatedAt
  refId
  billingId
  displayName
  status
  pricingType
  description
  environmentId
  productId
  isLatest
  versionNumber
}

"""Minimum spend configuration"""
type MinimumSpend {
  """Minimum spend billing period"""
  billingPeriod: BillingPeriod!

  """The minimum spend limit"""
  minimum: Money!
}

type StringChangeDTO {
  """The value before the change"""
  before: String

  """The value after the change"""
  after: String

  """The change type"""
  changeType: ChangeType
}

enum ChangeType {
  REORDERED
  MODIFIED
  ADDED
  DELETED
}

type NumberChange {
  """The value before the change"""
  before: Float

  """The value after the change"""
  after: Float

  """The change type"""
  changeType: ChangeType
}

type PackageEntitlementChange {
  """The value before the change"""
  before: PackageEntitlement

  """The value after the change"""
  after: PackageEntitlement

  """The change type"""
  changeType: ChangeType
}

type PackagePriceChange {
  """The value before the change"""
  before: Price

  """The value after the change"""
  after: Price

  """The change type"""
  changeType: ChangeType
}

type DefaultTrialConfigChange {
  """The value before the change"""
  before: DefaultTrialConfig

  """The value after the change"""
  after: DefaultTrialConfig

  """The change type"""
  changeType: ChangeType
}

"""Minimum spend change"""
type MinimumSpendChange {
  """The value before the change"""
  before: MinimumSpend

  """The value after the change"""
  after: MinimumSpend

  """The change type"""
  changeType: ChangeType
}

type OverageBillingPeriodChange {
  before: OverageBillingPeriod
  after: OverageBillingPeriod
  changeType: ChangeType
}

"""Configures when the overage charge is billed."""
enum OverageBillingPeriod {
  ON_SUBSCRIPTION_RENEWAL
  MONTHLY
}

type AdditionalMetaDataChange {
  before: JSON
  after: JSON
  changeType: ChangeType
}

type BasePlanChange {
  before: Addon
  after: Addon
  changeType: ChangeType
}

type PlanCompatibleAddonChange {
  before: Addon
  after: Addon
  changeType: ChangeType
}

"""Package group changed"""
type PlanCompatiblePackageGroupChange {
  """Package group before change"""
  before: PackageGroup

  """Package group after change"""
  after: PackageGroup

  """Type of change"""
  changeType: ChangeType
}

"""Addon dependency changed"""
type AddonDependencyChange {
  """Addon before change"""
  before: Addon

  """Addon after change"""
  after: Addon

  """Type of change"""
  changeType: ChangeType
}

type PricingTypeChange {
  before: PricingType
  after: PricingType
  changeType: ChangeType
}

type HiddenFromWidgetsChange {
  before: [WidgetType!]
  after: [WidgetType!]
  changeType: ChangeType
}

type PackageChanges {
  displayName: StringChangeDTO
  description: StringChangeDTO
  hiddenFromWidgets: HiddenFromWidgetsChange
  pricingType: PricingTypeChange
  entitlements: [PackageEntitlementChange!]!
  prices: [PackagePriceChange!]!
  overagePrices: [PackagePriceChange!]!
  compatibleAddons: [PlanCompatibleAddonChange!]

  """Package groups"""
  compatiblePackageGroups: [PlanCompatiblePackageGroupChange!]

  """Addon dependencies"""
  dependencies: [AddonDependencyChange!]
  basePlan: BasePlanChange
  defaultTrialConfig: DefaultTrialConfigChange

  """Minimum spend limit"""
  minimumSpend: [MinimumSpendChange!]
  additionalMetaData: AdditionalMetaDataChange

  """Max quantity for an addon"""
  maxQuantity: NumberChange

  """Configures when the overage charge is billed."""
  overageBillingPeriod: OverageBillingPeriodChange
  totalChanges: Int!
}

type PackageDraftSummary {
  version: Int!
  updatedAt: DateTime!
  updatedBy: String
}

type PackageDraftDetails {
  version: Int!
  updatedAt: DateTime!
  updatedBy: String
  customersAffected: Int
  childPlansWithDraft: [Plan!]
  affectedChildPlans: [Plan!]
  changes: PackageChanges
}

type Integration {
  id: String!
  createdAt: DateTime
  environmentId: String!
  vendorIdentifier: VendorIdentifier!

  """The vendor type"""
  vendorType: VendorType!

  """Whether the integration is the default"""
  isDefault: Boolean

  """The reference ID for the integration"""
  integrationId: String
  credentials: Credentials
  account: Account
  environment: Environment
}

"""The type of integration"""
enum VendorType {
  """Billing integration type"""
  BILLING

  """CRM integration type"""
  CRM

  """Data export integration type"""
  DATA_EXPORT

  """Authentication integration type"""
  AUTH

  """Marketplace integration type"""
  MARKETPLACE
}

union Credentials = Auth0Credentials | ZuoraCredentials | StripeCredentials | HubspotCredentials | AwsMarketplaceCredentials | SnowflakeCredentials | SalesforceCredentials | BigQueryCredentials | OpenFGACredentials

type Auth0Credentials {
  clientDomain: String!
  clientId: String!
  clientSecret: String!
  applicationId: String!
  applicationName: String!
  applicationType: Auth0ApplicationType!
  individualInitialPlanId: String
  individualSubscriptionStartSetup: SubscriptionStartSetup
  organizationInitialPlanId: String
  organizationSubscriptionStartSetup: SubscriptionStartSetup
}

type ZuoraCredentials {
  baseUrl: String!
  clientId: String!
  clientSecret: String!
  stripePublishableKey: String
  stripeSecretKey: String
  webhookSecret: String
  paymentPageId: String
}

type StripeCredentials {
  accountId: String!
  isTestMode: Boolean!
  accountDisplayName: String!
  isTaxEnabled: Boolean!
}

type HubspotCredentials {
  hubDomain: String!
}

type AwsMarketplaceCredentials {
  awsRoleArn: String!
}

type SnowflakeCredentials {
  host: String!
  database: String!
  schemaName: String!
  role: String!
  warehouse: String!
  username: String!
  airbyteDestinationId: String
  airbyteConnectionId: String
}

type SalesforceCredentials {
  domain: String
}

type BigQueryCredentials {
  projectId: String!
  datasetLocation: String!
  datasetId: String!
  hmacKeyAccessId: String!
  hmacKeySecret: String!
  gcsBucketName: String!
  gcsBucketPath: String!
  credentialsJson: String!
  airbyteDestinationId: String
  airbyteConnectionId: String
}

type OpenFGACredentials {
  apiUrl: String!
  apiAudience: String!
  apiTokenIssuer: String!
  clientId: String!
  storeId: String!
  modelId: String!
}

"""State of the integration sync"""
type SyncState {
  """Status of the integration sync"""
  status: SyncStatus!

  """Vendor identifier"""
  vendorIdentifier: VendorIdentifier!

  """Synced entity id"""
  syncedEntityId: String

  """Integration details"""
  integration: Integration!

  """Sync revision data"""
  data: SyncRevisionData

  """Error message"""
  error: String
}

"""Status of the integration sync"""
enum SyncStatus {
  PENDING
  ERROR
  SUCCESS
  NO_SYNC_REQUIRED
}

"""Data of the sync revision"""
union SyncRevisionData = SyncRevisionBillingData | SyncRevisionPriceBillingData | SyncRevisionMarketplaceData

"""Data of billing sync revision"""
type SyncRevisionBillingData {
  """The billing integration id"""
  billingId: String!

  """The billing integration url"""
  billingLinkUrl: String!
}

"""Data of price billing sync revision"""
type SyncRevisionPriceBillingData {
  """The billing integration id"""
  billingId: String!

  """The billing integration url"""
  billingLinkUrl: String!

  """The price group package billing id"""
  priceGroupPackageBillingId: String!
}

"""Data of marketplace sync revision"""
type SyncRevisionMarketplaceData {
  """The dimensions of the marketplace sync revision"""
  dimensions: String!
}

type PackageDTO {
  id: String!
  createdAt: DateTime
  updatedAt: DateTime
  refId: String!
  billingId: String
  billingLinkUrl: String
  displayName: String!
  status: PackageStatus!
  pricingType: PricingType
  description: String
  environmentId: String!
  type: String!
  productId: String
  isLatest: Boolean
  entitlements: [PackageEntitlement!]
  draftSummary: PackageDraftSummary
  draftDetails: PackageDraftDetails
  versionNumber: Int!
  additionalMetaData: JSON
  syncStates: [SyncState!]!
  hiddenFromWidgets: [WidgetType!]
  prices: [Price!]
  overagePrices: [Price!]
  overageBillingPeriod: OverageBillingPeriod
}

type Addon {
  id: String!
  createdAt: DateTime
  updatedAt: DateTime
  refId: String!
  billingId: String
  billingLinkUrl: String
  displayName: String!
  status: PackageStatus!
  pricingType: PricingType
  description: String
  environmentId: String!
  type: String!
  productId: String
  isLatest: Boolean
  entitlements: [PackageEntitlement!]
  draftSummary: PackageDraftSummary
  draftDetails: PackageDraftDetails
  versionNumber: Int!
  additionalMetaData: JSON
  syncStates: [SyncState!]
  hiddenFromWidgets: [WidgetType!]
  prices(
    """Specify to filter the records returned."""
    filter: PriceFilter = {}

    """Specify to sort results."""
    sorting: [PriceSort!] = [{field: createdAt, direction: DESC}]
  ): [Price!]
  overagePrices: [Price!]
  overageBillingPeriod: OverageBillingPeriod

  """The maximum quantity of this addon that can be added to a subscription"""
  maxQuantity: Float

  """List of addons this addon is dependant on"""
  dependencies: [Addon!]

  """Indicates if the addon has subscriptions"""
  hasSubscriptions: Boolean!
  product: Product
  environment: Environment!
}

input PriceFilter {
  and: [PriceFilter!]
  or: [PriceFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  billingPeriod: BillingPeriodFilterComparison
  billingModel: BillingModelFilterComparison
  billingCadence: BillingCadenceFilterComparison
  tiersMode: TiersModeFilterComparison
  billingId: StringFieldComparison
  package: PriceFilterPackageDTOFilter
}

input BillingPeriodFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: BillingPeriod
  neq: BillingPeriod
  gt: BillingPeriod
  gte: BillingPeriod
  lt: BillingPeriod
  lte: BillingPeriod
  like: BillingPeriod
  notLike: BillingPeriod
  iLike: BillingPeriod
  notILike: BillingPeriod
  in: [BillingPeriod!]
  notIn: [BillingPeriod!]
}

input BillingModelFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: BillingModel
  neq: BillingModel
  gt: BillingModel
  gte: BillingModel
  lt: BillingModel
  lte: BillingModel
  like: BillingModel
  notLike: BillingModel
  iLike: BillingModel
  notILike: BillingModel
  in: [BillingModel!]
  notIn: [BillingModel!]
}

input BillingCadenceFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: BillingCadence
  neq: BillingCadence
  gt: BillingCadence
  gte: BillingCadence
  lt: BillingCadence
  lte: BillingCadence
  like: BillingCadence
  notLike: BillingCadence
  iLike: BillingCadence
  notILike: BillingCadence
  in: [BillingCadence!]
  notIn: [BillingCadence!]
}

input TiersModeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: TiersMode
  neq: TiersMode
  gt: TiersMode
  gte: TiersMode
  lt: TiersMode
  lte: TiersMode
  like: TiersMode
  notLike: TiersMode
  iLike: TiersMode
  notILike: TiersMode
  in: [TiersMode!]
  notIn: [TiersMode!]
}

input PriceFilterPackageDTOFilter {
  and: [PriceFilterPackageDTOFilter!]
  or: [PriceFilterPackageDTOFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  refId: StringFieldComparison
  billingId: StringFieldComparison
  displayName: StringFieldComparison
  status: PackageStatusFilterComparison
  pricingType: PricingTypeFilterComparison
  description: StringFieldComparison
  environmentId: StringFieldComparison
  productId: StringFieldComparison
  isLatest: BooleanFieldComparison
  versionNumber: IntFieldComparison
}

input PriceSort {
  field: PriceSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PriceSortFields {
  id
  createdAt
  billingPeriod
  billingModel
  billingCadence
  tiersMode
  billingId
}

type Plan {
  id: String!
  createdAt: DateTime
  updatedAt: DateTime
  refId: String!
  billingId: String
  billingLinkUrl: String
  displayName: String!
  status: PackageStatus!
  pricingType: PricingType
  description: String
  environmentId: String!
  type: String!
  productId: String
  isLatest: Boolean
  entitlements: [PackageEntitlement!]
  draftSummary: PackageDraftSummary
  draftDetails: PackageDraftDetails
  versionNumber: Int!
  additionalMetaData: JSON
  syncStates: [SyncState!]
  hiddenFromWidgets: [WidgetType!]
  prices: [Price!]
  overagePrices: [Price!]
  overageBillingPeriod: OverageBillingPeriod
  isParent: Boolean!
  inheritedEntitlements(includeOverridden: Boolean = false): [PackageEntitlement!]
  defaultTrialConfig: DefaultTrialConfig
  awsMarketplacePlanDimension: String

  """Minimum spend configuration"""
  minimumSpend: [MinimumSpend!]
  compatiblePackageGroups: [PlanCompatiblePackageGroups!]
  product: Product!
  basePlan: Plan
  environment: Environment!
  compatibleAddons(
    """Specify to filter the records returned."""
    filter: AddonFilter = {}

    """Specify to sort results."""
    sorting: [AddonSort!] = [{field: createdAt, direction: DESC}]
  ): [Addon!]
}

type PromotionalEntitlement {
  id: String!
  description: String
  featureId: String!
  createdAt: DateTime
  updatedAt: DateTime
  startDate: DateTime!
  endDate: DateTime
  isVisible: Boolean!
  usageLimit: Float
  hasSoftLimit: Boolean
  hasUnlimitedUsage: Boolean
  unlimited: Boolean
  status: PromotionalEntitlementStatus!
  period: PromotionalEntitlementPeriod!
  resetPeriod: EntitlementResetPeriod
  resetPeriodConfiguration: ResetPeriodConfiguration
  environmentId: String!
  meter: Meter
  feature: Feature!
  customer: Customer!
}

"""Promotional entitlement status"""
enum PromotionalEntitlementStatus {
  Active
  Expired
  Paused
}

"""Promotional entitlement duration"""
enum PromotionalEntitlementPeriod {
  ONE_WEEK
  ONE_MONTH
  SIX_MONTH
  ONE_YEAR
  LIFETIME
  CUSTOM
}

type Coupon {
  """Unique identifier of the coupon"""
  id: String!

  """Name of the coupon"""
  name: String!

  """Customer-given identifier of the coupon"""
  refId: String!

  """Description of the coupon"""
  description: String

  """Date when the coupon was created"""
  createdAt: DateTime!

  """Date when the coupon was last updated"""
  updatedAt: DateTime!

  """ID of the environment the coupon belongs to"""
  environmentId: String!

  """Type of the coupon (percentage or fixed amount)"""
  type: CouponType!

  """Current status of the coupon"""
  status: CouponStatus!

  """The source of the coupon"""
  source: CouponSource!

  """Discount value of the coupon (deprecated)"""
  discountValue: Float! @deprecated(reason: "Use percentOff or amountsOff fields instead")

  """Percentage discount off the original price"""
  percentOff: Float

  """Fixed amount discounts in different currencies"""
  amountsOff: [Money!]

  """Additional metadata associated with the coupon"""
  additionalMetaData: JSON

  """ID of the coupon in the billing system"""
  billingId: String

  """URL to the coupon in the billing system"""
  billingLinkUrl: String
  syncStates: [SyncState!]

  """Duration of the coupon validity in months"""
  durationInMonths: Float
  environment: Environment
  customers(
    """Specify to filter the records returned."""
    filter: CustomerFilter = {}

    """Specify to sort results."""
    sorting: [CustomerSort!] = [{field: createdAt, direction: DESC}]
  ): [Customer!]
}

"""The type of the coupon"""
enum CouponType {
  FIXED
  PERCENTAGE
}

"""The status of the coupon"""
enum CouponStatus {
  ACTIVE
  ARCHIVED
}

"""The source of the coupon"""
enum CouponSource {
  STIGG
  STIGG_ADHOC
  STRIPE
}

input CustomerFilter {
  and: [CustomerFilter!]
  or: [CustomerFilter!]
  id: StringFieldComparison
  name: StringFieldComparison
  email: StringFieldComparison
  refId: StringFieldComparison
  customerId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  environmentId: StringFieldComparison
  billingId: StringFieldComparison
  crmId: StringFieldComparison
  crmHubspotCompanyId: StringFieldComparison
  crmHubspotCompanyUrl: StringFieldComparison
  searchQuery: CustomerSearchQueryFilterComparison
  promotionalEntitlements: CustomerFilterPromotionalEntitlementFilter
  subscriptions: CustomerFilterCustomerSubscriptionFilter
}

input CustomerSearchQueryFilterComparison {
  iLike: String
}

input CustomerFilterPromotionalEntitlementFilter {
  and: [CustomerFilterPromotionalEntitlementFilter!]
  or: [CustomerFilterPromotionalEntitlementFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  status: PromotionalEntitlementStatusFilterComparison
  environmentId: StringFieldComparison
}

input PromotionalEntitlementStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PromotionalEntitlementStatus
  neq: PromotionalEntitlementStatus
  gt: PromotionalEntitlementStatus
  gte: PromotionalEntitlementStatus
  lt: PromotionalEntitlementStatus
  lte: PromotionalEntitlementStatus
  like: PromotionalEntitlementStatus
  notLike: PromotionalEntitlementStatus
  iLike: PromotionalEntitlementStatus
  notILike: PromotionalEntitlementStatus
  in: [PromotionalEntitlementStatus!]
  notIn: [PromotionalEntitlementStatus!]
}

input CustomerFilterCustomerSubscriptionFilter {
  and: [CustomerFilterCustomerSubscriptionFilter!]
  or: [CustomerFilterCustomerSubscriptionFilter!]
  environmentId: StringFieldComparison
  id: StringFieldComparison
  createdAt: DateFieldComparison
  startDate: DateFieldComparison
  endDate: DateFieldComparison
  cancellationDate: DateFieldComparison
  trialEndDate: DateFieldComparison
  effectiveEndDate: DateFieldComparison
  billingCycleAnchor: DateFieldComparison
  billingId: StringFieldComparison
  oldBillingId: StringFieldComparison
  crmId: StringFieldComparison
  crmLinkUrl: StringFieldComparison
  status: SubscriptionStatusFilterComparison
  cancelReason: SubscriptionCancelReasonFilterComparison
  refId: StringFieldComparison
  subscriptionId: StringFieldComparison
  customerId: StringFieldComparison
  payingCustomerId: StringFieldComparison
  resourceId: StringFieldComparison
  currentBillingPeriodStart: DateFieldComparison
  currentBillingPeriodEnd: DateFieldComparison
  pricingType: PricingTypeFilterComparison
  paymentCollection: PaymentCollectionFilterComparison
}

input SubscriptionStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: SubscriptionStatus
  neq: SubscriptionStatus
  gt: SubscriptionStatus
  gte: SubscriptionStatus
  lt: SubscriptionStatus
  lte: SubscriptionStatus
  like: SubscriptionStatus
  notLike: SubscriptionStatus
  iLike: SubscriptionStatus
  notILike: SubscriptionStatus
  in: [SubscriptionStatus!]
  notIn: [SubscriptionStatus!]
}

"""Subscription status"""
enum SubscriptionStatus {
  PAYMENT_PENDING
  ACTIVE
  EXPIRED
  IN_TRIAL
  CANCELED
  NOT_STARTED
}

input SubscriptionCancelReasonFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: SubscriptionCancelReason
  neq: SubscriptionCancelReason
  gt: SubscriptionCancelReason
  gte: SubscriptionCancelReason
  lt: SubscriptionCancelReason
  lte: SubscriptionCancelReason
  like: SubscriptionCancelReason
  notLike: SubscriptionCancelReason
  iLike: SubscriptionCancelReason
  notILike: SubscriptionCancelReason
  in: [SubscriptionCancelReason!]
  notIn: [SubscriptionCancelReason!]
}

"""Subscription cancellation status"""
enum SubscriptionCancelReason {
  UpgradeOrDowngrade
  CancelledByBilling
  Expired
  DetachBilling
  TrialEnded
  Immediate
  TrialConverted
  PendingPaymentExpired
  ScheduledCancellation
  CustomerArchived
  AutoCancellationRule
}

input PaymentCollectionFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PaymentCollection
  neq: PaymentCollection
  gt: PaymentCollection
  gte: PaymentCollection
  lt: PaymentCollection
  lte: PaymentCollection
  like: PaymentCollection
  notLike: PaymentCollection
  iLike: PaymentCollection
  notILike: PaymentCollection
  in: [PaymentCollection!]
  notIn: [PaymentCollection!]
}

"""Payment collection"""
enum PaymentCollection {
  NOT_REQUIRED
  PROCESSING
  FAILED
  ACTION_REQUIRED
}

input CustomerSort {
  field: CustomerSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CustomerSortFields {
  id
  name
  email
  refId
  customerId
  createdAt
  updatedAt
  deletedAt
  environmentId
  billingId
  crmId
  crmHubspotCompanyId
  crmHubspotCompanyUrl
  searchQuery
}

type TrialedPlan {
  productId: String
  planId: String
  planRefId: String
  productRefId: String
}

type experimentInfo {
  id: String!
  name: String!
  status: ExperimentStatus!
  groupType: experimentGroupType!
  groupName: String!
}

"""The status of the EXPERIMENT"""
enum ExperimentStatus {
  DRAFT
  IN_PROGRESS
  COMPLETED
}

"""The group of the experiment"""
enum experimentGroupType {
  CONTROL
  VARIANT
}

type Experiment {
  id: String!
  name: String!
  refId: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  startedAt: DateTime
  stoppedAt: DateTime
  environmentId: String!
  productId: String!
  status: ExperimentStatus!
  variantPercentage: Float!
  controlGroupName: String!
  variantGroupName: String!
  productSettings: ProductSettings!
  initialProductSettings: ProductSettings
  customers: Customer
  product: Product
  environment: Environment
}

type EligibleForTrial {
  productId: String
  productRefId: String
  eligible: Boolean!
}

type SubscriptionPricingTypeStatistics {
  pricingType: PricingType!
  totalCount: Float!
}

type CustomerStatistics {
  activeSubscriptionsByPricingType: [SubscriptionPricingTypeStatistics!]!
}

type Customer {
  id: String!
  name: String
  email: String
  refId: String! @deprecated(reason: "Renamed to customerId")
  customerId: String!
  createdAt: DateTime
  updatedAt: DateTime!
  deletedAt: DateTime
  environmentId: String!
  billingId: String
  billingLinkUrl: String
  crmId: String
  crmHubspotCompanyId: String
  crmHubspotCompanyUrl: String
  hasPaymentMethod: Boolean!
  hasActiveSubscription: Boolean!
  additionalMetaData: JSON
  syncStates: [SyncState!]
  defaultPaymentMethodId: String
  defaultPaymentMethodType: PaymentMethodType
  defaultPaymentMethodLast4Digits: String
  defaultPaymentExpirationMonth: Int
  defaultPaymentExpirationYear: Int
  trialedPlans: [TrialedPlan!]
  experimentInfo: experimentInfo
  excludeFromExperiment: Boolean
  eligibleForTrial: [EligibleForTrial!]
  billingCurrency: Currency
  awsMarketplaceCustomerId: String
  salesforceId: String
  statistics: CustomerStatistics
  hasActiveResource: Boolean!
  totalActiveSubscription: Float!
  totalActivePromotionalEntitlements: Float!
  environment: Environment
  coupon: Coupon
  experiment: Experiment
  subscriptions(
    """Specify to filter the records returned."""
    filter: CustomerSubscriptionFilter = {status: {in: [ACTIVE, IN_TRIAL]}}

    """Specify to sort results."""
    sorting: [CustomerSubscriptionSort!] = [{field: createdAt, direction: DESC}]
  ): [CustomerSubscription!]
  promotionalEntitlements(
    """Specify to filter the records returned."""
    filter: PromotionalEntitlementFilter = {}

    """Specify to sort results."""
    sorting: [PromotionalEntitlementSort!] = [{field: createdAt, direction: DESC}]
  ): [PromotionalEntitlement!]!
}

"""Type of a payment method"""
enum PaymentMethodType {
  CARD
  BANK
}

input CustomerSubscriptionFilter {
  and: [CustomerSubscriptionFilter!]
  or: [CustomerSubscriptionFilter!]
  environmentId: StringFieldComparison
  id: StringFieldComparison
  createdAt: DateFieldComparison
  startDate: DateFieldComparison
  endDate: DateFieldComparison
  cancellationDate: DateFieldComparison
  trialEndDate: DateFieldComparison
  effectiveEndDate: DateFieldComparison
  billingCycleAnchor: DateFieldComparison
  billingId: StringFieldComparison
  oldBillingId: StringFieldComparison
  crmId: StringFieldComparison
  crmLinkUrl: StringFieldComparison
  status: SubscriptionStatusFilterComparison
  cancelReason: SubscriptionCancelReasonFilterComparison
  refId: StringFieldComparison
  subscriptionId: StringFieldComparison
  customerId: StringFieldComparison
  payingCustomerId: StringFieldComparison
  resourceId: StringFieldComparison
  currentBillingPeriodStart: DateFieldComparison
  currentBillingPeriodEnd: DateFieldComparison
  pricingType: PricingTypeFilterComparison
  paymentCollection: PaymentCollectionFilterComparison
  plan: CustomerSubscriptionFilterPlanFilter
  resource: CustomerSubscriptionFilterCustomerResourceFilter
  payingCustomer: CustomerSubscriptionFilterCustomerFilter
  customer: CustomerSubscriptionFilterCustomerFilter
  prices: CustomerSubscriptionFilterSubscriptionPriceFilter
  addons: CustomerSubscriptionFilterSubscriptionAddonFilter
  subscriptionEntitlements: CustomerSubscriptionFilterSubscriptionEntitlementFilter
}

input CustomerSubscriptionFilterPlanFilter {
  and: [CustomerSubscriptionFilterPlanFilter!]
  or: [CustomerSubscriptionFilterPlanFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  refId: StringFieldComparison
  billingId: StringFieldComparison
  displayName: StringFieldComparison
  status: PackageStatusFilterComparison
  pricingType: PricingTypeFilterComparison
  description: StringFieldComparison
  environmentId: StringFieldComparison
  productId: StringFieldComparison
  isLatest: BooleanFieldComparison
  versionNumber: IntFieldComparison
}

input CustomerSubscriptionFilterCustomerResourceFilter {
  and: [CustomerSubscriptionFilterCustomerResourceFilter!]
  or: [CustomerSubscriptionFilterCustomerResourceFilter!]
  environmentId: StringFieldComparison
  resourceId: StringFieldComparison
  createdAt: DateFieldComparison
}

input CustomerSubscriptionFilterCustomerFilter {
  and: [CustomerSubscriptionFilterCustomerFilter!]
  or: [CustomerSubscriptionFilterCustomerFilter!]
  id: StringFieldComparison
  name: StringFieldComparison
  email: StringFieldComparison
  refId: StringFieldComparison
  customerId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  environmentId: StringFieldComparison
  billingId: StringFieldComparison
  crmId: StringFieldComparison
  crmHubspotCompanyId: StringFieldComparison
  crmHubspotCompanyUrl: StringFieldComparison
  searchQuery: CustomerSearchQueryFilterComparison
}

input CustomerSubscriptionFilterSubscriptionPriceFilter {
  and: [CustomerSubscriptionFilterSubscriptionPriceFilter!]
  or: [CustomerSubscriptionFilterSubscriptionPriceFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  usageLimit: NumberFieldComparison
  hasSoftLimit: BooleanFieldComparison
  featureId: StringFieldComparison
  billingModel: BillingModelFilterComparison
}

input NumberFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: Float
  neq: Float
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  in: [Float!]
  notIn: [Float!]
  between: NumberFieldComparisonBetween
  notBetween: NumberFieldComparisonBetween
}

input NumberFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

input CustomerSubscriptionFilterSubscriptionAddonFilter {
  and: [CustomerSubscriptionFilterSubscriptionAddonFilter!]
  or: [CustomerSubscriptionFilterSubscriptionAddonFilter!]
  id: StringFieldComparison
  quantity: NumberFieldComparison
  updatedAt: DateFieldComparison
  createdAt: DateFieldComparison
}

input CustomerSubscriptionFilterSubscriptionEntitlementFilter {
  and: [CustomerSubscriptionFilterSubscriptionEntitlementFilter!]
  or: [CustomerSubscriptionFilterSubscriptionEntitlementFilter!]
  id: StringFieldComparison
  subscriptionId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  environmentId: StringFieldComparison
}

input CustomerSubscriptionSort {
  field: CustomerSubscriptionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CustomerSubscriptionSortFields {
  environmentId
  id
  createdAt
  startDate
  endDate
  cancellationDate
  trialEndDate
  effectiveEndDate
  billingCycleAnchor
  billingId
  oldBillingId
  crmId
  crmLinkUrl
  status
  cancelReason
  refId
  subscriptionId
  customerId
  payingCustomerId
  resourceId
  currentBillingPeriodStart
  currentBillingPeriodEnd
  pricingType
  paymentCollection
}

input PromotionalEntitlementFilter {
  and: [PromotionalEntitlementFilter!]
  or: [PromotionalEntitlementFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  status: PromotionalEntitlementStatusFilterComparison
  environmentId: StringFieldComparison
}

input PromotionalEntitlementSort {
  field: PromotionalEntitlementSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PromotionalEntitlementSortFields {
  id
  createdAt
  updatedAt
  status
  environmentId
}

type SubscriptionAddon {
  id: String!
  quantity: Float!
  updatedAt: DateTime!
  createdAt: DateTime

  """The id of the addon"""
  addonId: String!

  """Addon object"""
  addon: Addon!
  subscription: CustomerSubscription!
  price: Price
}

type SubscriptionPrice {
  id: String!
  createdAt: DateTime
  updatedAt: DateTime!
  usageLimit: Float
  hasSoftLimit: Boolean
  featureId: String
  billingModel: BillingModel
  subscription: CustomerSubscription!
  price: Price
}

type CustomerSubscriptionTotalPrice {
  subTotal: Money!
  total: Money!
  addonsTotal: Money!
}

type SubscriptionEntitlement {
  id: String!
  description: String
  featureId: String!
  subscriptionId: String!
  createdAt: DateTime
  updatedAt: DateTime
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  environmentId: String!
  resetPeriod: EntitlementResetPeriod
  resetPeriodConfiguration: ResetPeriodConfiguration
  meter: Meter
  feature: Feature!
  subscription: CustomerSubscription!
}

type BillableFeature {
  featureId: String!
  quantity: Float!
}

type PlanChangeAddon {
  addonRefId: String!
  quantity: Float!
}

type PriceOverrideChangeVariables {
  planRefId: String
  addonRefId: String
  featureId: String
}

type SubscriptionFutureUpdate {
  createdAt: DateTime
  scheduledExecutionTime: DateTime!
  billingId: String
  subscriptionScheduleType: SubscriptionScheduleType!
  scheduleStatus: SubscriptionScheduleStatus!
  targetPackage: PackageDTO

  """The schedule variables by the type of the schedule"""
  scheduleVariables: ScheduleVariables
}

"""Subscription scheduled schedule type"""
enum SubscriptionScheduleType {
  """Downgrade change"""
  Downgrade

  """Plan change"""
  Plan

  """Billing period change"""
  BillingPeriod

  """Unit amount change"""
  UnitAmount

  """Custom price change"""
  PriceOverride

  """Addon change"""
  Addon

  """Coupon change"""
  Coupon

  """Migrate to latest"""
  MigrateToLatest

  """Additional metadata change"""
  AdditionalMetaData
}

"""Subscription scheduled schedule status"""
enum SubscriptionScheduleStatus {
  PendingPayment
  Scheduled
  Canceled
  Done
  Failed
}

"""Schedule variables by the type of the schedule"""
union ScheduleVariables = DowngradeChangeVariables | PlanChangeVariables | BillingPeriodChangeVariables | UnitAmountChangeVariables | AddonChangeVariables | CouponChangeVariables | PlanPriceOverrideChangeVariables | AddonPriceOverrideChangeVariables

type DowngradeChangeVariables {
  downgradePlanRefId: String!
  billingPeriod: BillingPeriod
  billableFeatures: [BillableFeature!]
  addonRefIds: String @deprecated(reason: "Use addons instead")
  addons: [PlanChangeAddon!]
  priceOverrides: [PriceOverrideChangeVariables!]
}

type PlanChangeVariables {
  planRefId: String!
  changeType: PlanChangeType!
  billingPeriod: BillingPeriod
  billableFeatures: [BillableFeature!]
  addons: [PlanChangeAddon!]
  priceOverrides: [PriceOverrideChangeVariables!]
}

"""Type of the change between two plans of the same subscription"""
enum PlanChangeType {
  """Subscription upgrade to higher plan"""
  UPGRADE

  """Subscription downgrade to lower plan"""
  DOWNGRADE

  """Subscription remains on the same plan"""
  NONE
}

type BillingPeriodChangeVariables {
  billingPeriod: BillingPeriod
}

type UnitAmountChangeVariables {
  newUnitAmount: Float
  featureId: String
}

type AddonChangeVariables {
  newQuantity: Float!
  addonRefId: String!
}

"""Coupon change variables"""
type CouponChangeVariables {
  """Coupon reference ID"""
  couponId: String!
}

type PlanPriceOverrideChangeVariables {
  planRefId: String!
  featureId: String
}

type AddonPriceOverrideChangeVariables {
  addonRefId: String!
  featureId: String
}

type SubscriptionScheduledUpdate {
  createdAt: DateTime
  scheduledExecutionTime: DateTime!
  billingId: String
  subscriptionScheduleType: SubscriptionScheduleType!
  scheduleStatus: SubscriptionScheduleStatus!
  targetPackage: PackageDTO

  """The schedule variables by the type of the schedule"""
  scheduleVariables: ScheduleVariables
}

type CustomerResource {
  environmentId: String!
  resourceId: String!
  createdAt: DateTime!
  customer: Customer!
  subscriptions(
    """Specify to filter the records returned."""
    filter: CustomerSubscriptionFilter = {status: {in: [ACTIVE, IN_TRIAL]}}

    """Specify to sort results."""
    sorting: [CustomerSubscriptionSort!] = [{field: createdAt, direction: DESC}]
  ): [CustomerSubscription!]!
}

type InvoiceLine {
  description: String
  quantity: Int
  currency: String!
  amount: Float!
  proration: Boolean!
}

type SubscriptionInvoice {
  billingId: String!
  status: SubscriptionInvoiceStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  requiresAction: Boolean!
  paymentSecret: String
  paymentUrl: String
  errorMessage: String
  pdfUrl: String
  currency: String
  lines: [InvoiceLine!]
  subTotal: Float
  subTotalExcludingTax: Float
  total: Float
  totalExcludingTax: Float
  tax: Float
  startingBalance: Float
  endingBalance: Float
  appliedBalance: Float
  amountDue: Float
  billingReason: SubscriptionInvoiceBillingReason

  """
  Number of payment attempts made for this invoice, from the perspective of the payment retry schedule.
  """
  attemptCount: Float
}

"""SubscriptionInvoice status"""
enum SubscriptionInvoiceStatus {
  OPEN
  CANCELED
  PAID
}

"""The reason the billing event was created."""
enum SubscriptionInvoiceBillingReason {
  """A subscription advanced into a new billing cycle."""
  BILLING_CYCLE

  """A subscription was created."""
  SUBSCRIPTION_CREATION

  """A subscription was updated."""
  SUBSCRIPTION_UPDATE

  """An invoice was created manually."""
  MANUAL

  """A subscription passed the minimum invoice amount"""
  MINIMUM_INVOICE_AMOUNT_EXCEEDED

  """An invoice was created for another reason."""
  OTHER
}

"""Free subscription item"""
type FreeSubscriptionItem {
  """The add-on id"""
  addonId: String!

  """The quantity of free items"""
  quantity: Float!
}

"""Subscription minimum spend"""
type SubscriptionMinimumSpend {
  """The minimum spend limit"""
  minimum: Money

  """Is the minimum spend an override on the subscription level"""
  isOverride: Boolean
}

"""Trial configuration"""
type TrialConfiguration {
  """Indicates the behavior of the subscription when the trial is expired."""
  trialEndBehavior: TrialEndBehavior!
}

type SubscriptionCoupon {
  id: String!
  name: String!
  refId: String!
  environmentId: String!
  type: CouponType!
  discountValue: Float! @deprecated(reason: "Use percentOff or amountsOff fields instead")

  """Discount percent off"""
  percentOff: Float

  """Discount amounts off"""
  amountsOff: [Money!]

  """The status of this coupon"""
  status: SubscriptionCouponStatus!

  """The duration of the coupon in months"""
  durationInMonths: Float

  """The start date of this coupon"""
  startDate: DateTime

  """The expiration date of this coupon"""
  expirationDate: DateTime
}

"""The status of the subscription coupon"""
enum SubscriptionCouponStatus {
  ACTIVE
  EXPIRED
  REMOVED
}

type CustomerSubscription {
  environmentId: String!
  id: String!
  createdAt: DateTime
  startDate: DateTime!
  endDate: DateTime
  cancellationDate: DateTime
  trialEndDate: DateTime
  effectiveEndDate: DateTime

  """Billing cycle anchor date"""
  billingCycleAnchor: DateTime
  billingId: String
  oldBillingId: String
  billingLinkUrl: String
  crmId: String
  crmLinkUrl: String
  status: SubscriptionStatus!
  cancelReason: SubscriptionCancelReason
  refId: String! @deprecated(reason: "Renamed to subscriptionId")
  subscriptionId: String!
  customerId: String
  payingCustomerId: String
  resourceId: String
  wasInTrial: Boolean
  addons(
    """Specify to filter the records returned."""
    filter: SubscriptionAddonFilter = {}

    """Specify to sort results."""
    sorting: [SubscriptionAddonSort!] = [{field: createdAt, direction: DESC}]
  ): [SubscriptionAddon!]
  currentBillingPeriodStart: DateTime
  currentBillingPeriodEnd: DateTime
  pricingType: PricingType!
  additionalMetaData: JSON
  syncStates: [SyncState!]
  totalPrice: CustomerSubscriptionTotalPrice
  experimentInfo: experimentInfo

  """Active coupon for this subscription"""
  coupon: SubscriptionCoupon

  """List of coupons for this subscription"""
  coupons: [SubscriptionCoupon!]
  subscriptionEntitlements(
    """Specify to filter the records returned."""
    filter: SubscriptionEntitlementFilter = {}

    """Specify to sort results."""
    sorting: [SubscriptionEntitlementSort!] = [{field: createdAt, direction: DESC}]
  ): [SubscriptionEntitlement!]
  scheduledUpdates: [SubscriptionScheduledUpdate!]
  latestInvoice: SubscriptionInvoice
  lastUsageInvoice: SubscriptionInvoice
  paymentCollection: PaymentCollection!
  billingSyncError: String
  salesforceId: String
  freeItems: [FreeSubscriptionItem!]

  """Budget configuration"""
  budget: BudgetConfiguration

  """Minimum spend configuration"""
  minimumSpend: SubscriptionMinimumSpend

  """Indicates if the budget has been exceeded"""
  budgetExceeded: Boolean

  """Payment collection method of the subscription"""
  paymentCollectionMethod: PaymentCollectionMethod

  """Trial configuration"""
  trialConfiguration: TrialConfiguration
  outdatedPricePackages: [String!]
  futureUpdates: [SubscriptionFutureUpdate!]!
  isCustomPriceSubscription: Boolean @deprecated(reason: "Use paymentCollectionMethod field and look for 'None' value")
  customer: Customer!
  payingCustomer: Customer
  resource: CustomerResource
  plan: Plan!
  environment: Environment!
  experiment: Experiment
  prices(
    """Specify to filter the records returned."""
    filter: SubscriptionPriceFilter = {billingModel: {neq: MINIMUM_SPEND}}

    """Specify to sort results."""
    sorting: [SubscriptionPriceSort!] = [{field: createdAt, direction: DESC}]
  ): [SubscriptionPrice!]
}

input SubscriptionAddonFilter {
  and: [SubscriptionAddonFilter!]
  or: [SubscriptionAddonFilter!]
  id: StringFieldComparison
  quantity: NumberFieldComparison
  updatedAt: DateFieldComparison
  createdAt: DateFieldComparison
  price: SubscriptionAddonFilterPriceFilter
  subscription: SubscriptionAddonFilterCustomerSubscriptionFilter
}

input SubscriptionAddonFilterPriceFilter {
  and: [SubscriptionAddonFilterPriceFilter!]
  or: [SubscriptionAddonFilterPriceFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  billingPeriod: BillingPeriodFilterComparison
  billingModel: BillingModelFilterComparison
  billingCadence: BillingCadenceFilterComparison
  tiersMode: TiersModeFilterComparison
  billingId: StringFieldComparison
}

input SubscriptionAddonFilterCustomerSubscriptionFilter {
  and: [SubscriptionAddonFilterCustomerSubscriptionFilter!]
  or: [SubscriptionAddonFilterCustomerSubscriptionFilter!]
  environmentId: StringFieldComparison
  id: StringFieldComparison
  createdAt: DateFieldComparison
  startDate: DateFieldComparison
  endDate: DateFieldComparison
  cancellationDate: DateFieldComparison
  trialEndDate: DateFieldComparison
  effectiveEndDate: DateFieldComparison
  billingCycleAnchor: DateFieldComparison
  billingId: StringFieldComparison
  oldBillingId: StringFieldComparison
  crmId: StringFieldComparison
  crmLinkUrl: StringFieldComparison
  status: SubscriptionStatusFilterComparison
  cancelReason: SubscriptionCancelReasonFilterComparison
  refId: StringFieldComparison
  subscriptionId: StringFieldComparison
  customerId: StringFieldComparison
  payingCustomerId: StringFieldComparison
  resourceId: StringFieldComparison
  currentBillingPeriodStart: DateFieldComparison
  currentBillingPeriodEnd: DateFieldComparison
  pricingType: PricingTypeFilterComparison
  paymentCollection: PaymentCollectionFilterComparison
}

input SubscriptionAddonSort {
  field: SubscriptionAddonSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SubscriptionAddonSortFields {
  id
  quantity
  updatedAt
  createdAt
}

input SubscriptionEntitlementFilter {
  and: [SubscriptionEntitlementFilter!]
  or: [SubscriptionEntitlementFilter!]
  id: StringFieldComparison
  subscriptionId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  environmentId: StringFieldComparison
  subscription: SubscriptionEntitlementFilterCustomerSubscriptionFilter
  feature: SubscriptionEntitlementFilterFeatureFilter
}

input SubscriptionEntitlementFilterCustomerSubscriptionFilter {
  and: [SubscriptionEntitlementFilterCustomerSubscriptionFilter!]
  or: [SubscriptionEntitlementFilterCustomerSubscriptionFilter!]
  environmentId: StringFieldComparison
  id: StringFieldComparison
  createdAt: DateFieldComparison
  startDate: DateFieldComparison
  endDate: DateFieldComparison
  cancellationDate: DateFieldComparison
  trialEndDate: DateFieldComparison
  effectiveEndDate: DateFieldComparison
  billingCycleAnchor: DateFieldComparison
  billingId: StringFieldComparison
  oldBillingId: StringFieldComparison
  crmId: StringFieldComparison
  crmLinkUrl: StringFieldComparison
  status: SubscriptionStatusFilterComparison
  cancelReason: SubscriptionCancelReasonFilterComparison
  refId: StringFieldComparison
  subscriptionId: StringFieldComparison
  customerId: StringFieldComparison
  payingCustomerId: StringFieldComparison
  resourceId: StringFieldComparison
  currentBillingPeriodStart: DateFieldComparison
  currentBillingPeriodEnd: DateFieldComparison
  pricingType: PricingTypeFilterComparison
  paymentCollection: PaymentCollectionFilterComparison
}

input SubscriptionEntitlementFilterFeatureFilter {
  and: [SubscriptionEntitlementFilterFeatureFilter!]
  or: [SubscriptionEntitlementFilterFeatureFilter!]
  id: StringFieldComparison
  displayName: StringFieldComparison
  refId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  description: StringFieldComparison
  featureType: FeatureTypeFilterComparison
  meterType: MeterTypeFilterComparison
  featureStatus: FeatureStatusFilterComparison
  environmentId: StringFieldComparison
}

input FeatureTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: FeatureType
  neq: FeatureType
  gt: FeatureType
  gte: FeatureType
  lt: FeatureType
  lte: FeatureType
  like: FeatureType
  notLike: FeatureType
  iLike: FeatureType
  notILike: FeatureType
  in: [FeatureType!]
  notIn: [FeatureType!]
}

input MeterTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: MeterType
  neq: MeterType
  gt: MeterType
  gte: MeterType
  lt: MeterType
  lte: MeterType
  like: MeterType
  notLike: MeterType
  iLike: MeterType
  notILike: MeterType
  in: [MeterType!]
  notIn: [MeterType!]
}

input FeatureStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: FeatureStatus
  neq: FeatureStatus
  gt: FeatureStatus
  gte: FeatureStatus
  lt: FeatureStatus
  lte: FeatureStatus
  like: FeatureStatus
  notLike: FeatureStatus
  iLike: FeatureStatus
  notILike: FeatureStatus
  in: [FeatureStatus!]
  notIn: [FeatureStatus!]
}

input SubscriptionEntitlementSort {
  field: SubscriptionEntitlementSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SubscriptionEntitlementSortFields {
  id
  subscriptionId
  createdAt
  updatedAt
  environmentId
}

"""The method used to collect payments for a subscription"""
enum PaymentCollectionMethod {
  """Automatically charge the payment method on file"""
  CHARGE

  """Generate an invoice to the customer to pay manually"""
  INVOICE

  """Do not leverage Stigg to manage payments for this subscription"""
  NONE
}

input SubscriptionPriceFilter {
  and: [SubscriptionPriceFilter!]
  or: [SubscriptionPriceFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  usageLimit: NumberFieldComparison
  hasSoftLimit: BooleanFieldComparison
  featureId: StringFieldComparison
  billingModel: BillingModelFilterComparison
  price: SubscriptionPriceFilterPriceFilter
  subscription: SubscriptionPriceFilterCustomerSubscriptionFilter
}

input SubscriptionPriceFilterPriceFilter {
  and: [SubscriptionPriceFilterPriceFilter!]
  or: [SubscriptionPriceFilterPriceFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  billingPeriod: BillingPeriodFilterComparison
  billingModel: BillingModelFilterComparison
  billingCadence: BillingCadenceFilterComparison
  tiersMode: TiersModeFilterComparison
  billingId: StringFieldComparison
}

input SubscriptionPriceFilterCustomerSubscriptionFilter {
  and: [SubscriptionPriceFilterCustomerSubscriptionFilter!]
  or: [SubscriptionPriceFilterCustomerSubscriptionFilter!]
  environmentId: StringFieldComparison
  id: StringFieldComparison
  createdAt: DateFieldComparison
  startDate: DateFieldComparison
  endDate: DateFieldComparison
  cancellationDate: DateFieldComparison
  trialEndDate: DateFieldComparison
  effectiveEndDate: DateFieldComparison
  billingCycleAnchor: DateFieldComparison
  billingId: StringFieldComparison
  oldBillingId: StringFieldComparison
  crmId: StringFieldComparison
  crmLinkUrl: StringFieldComparison
  status: SubscriptionStatusFilterComparison
  cancelReason: SubscriptionCancelReasonFilterComparison
  refId: StringFieldComparison
  subscriptionId: StringFieldComparison
  customerId: StringFieldComparison
  payingCustomerId: StringFieldComparison
  resourceId: StringFieldComparison
  currentBillingPeriodStart: DateFieldComparison
  currentBillingPeriodEnd: DateFieldComparison
  pricingType: PricingTypeFilterComparison
  paymentCollection: PaymentCollectionFilterComparison
}

input SubscriptionPriceSort {
  field: SubscriptionPriceSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SubscriptionPriceSortFields {
  id
  createdAt
  updatedAt
  usageLimit
  hasSoftLimit
  featureId
  billingModel
}

type MemberNotFoundError {
  code: String!
}

type MemberInvitationError {
  code: String!
  reason: String!
}

type InvalidMemberDeleteError {
  code: String!
  isValidationError: Boolean!
}

type CustomerNotFoundError {
  code: String!
  isValidationError: Boolean!
  refId: String!
}

type EntitlementFeature {
  id: String!
  displayName: String!
  refId: String!
  featureUnits: String
  featureUnitsPlural: String
  description: String
  featureType: FeatureType!
  meterType: MeterType
  featureStatus: FeatureStatus!
  additionalMetaData: JSON

  """Unit transformation to be applied to the reported usage"""
  unitTransformation: UnitTransformation
}

type Entitlement {
  isGranted: Boolean!
  customerId: String @deprecated(reason: "No longer in use")
  resourceId: String @deprecated(reason: "No longer in use")
  accessDeniedReason: AccessDeniedReason
  currentUsage: Float
  requestedUsage: Float
  usageLimit: Float
  hasSoftLimit: Boolean
  hasUnlimitedUsage: Boolean!

  """
  The anchor for calculating the usage period for metered entitlements with a reset period configured
  """
  usagePeriodAnchor: DateTime

  """
  The start date of the usage period for metered entitlements with a reset period configured
  """
  usagePeriodStart: DateTime

  """
  The end date of the usage period for metered entitlements with a reset period configured
  """
  usagePeriodEnd: DateTime
  nextResetDate: DateTime @deprecated(reason: "renamed to usagePeriodEnd")
  usageUpdatedAt: DateTime
  entitlementUpdatedAt: DateTime
  resetPeriod: EntitlementResetPeriod
  resetPeriodConfiguration: ResetPeriodConfiguration
  feature: EntitlementFeature
  meterId: String
  hiddenFromWidgets: [WidgetType!]
  displayNameOverride: String
}

"""DenyReason of get access policy"""
enum AccessDeniedReason {
  FeatureNotFound
  CustomerNotFound
  CustomerIsArchived
  CustomerResourceNotFound
  NoActiveSubscription
  NoFeatureEntitlementInSubscription
  RequestedUsageExceedingLimit
  BudgetExceeded
  Unknown
}

type EntitlementsUpdated {
  entitlements: [Entitlement!]!
  customerId: String!
  resourceId: String
  accountId: String!
  environmentId: String!
}

type SubscriptionMustHaveSinglePlanError {
  code: String!
  isValidationError: Boolean!
  refIds: [String!]!
}

type PriceNotFoundError {
  code: String!
  isValidationError: Boolean!
}

type CustomerNoBillingId {
  code: String!
  isValidationError: Boolean!
  refId: String!
}

type PromotionCodeCustomerNotFirstPurchase {
  code: String!
  isValidationError: Boolean!
}

type PromotionCodeMaxRedemptionsReached {
  code: String!
  isValidationError: Boolean!
}

type PromotionCodeMinimumAmountNotReached {
  code: String!
  isValidationError: Boolean!
}

type PromotionCodeNotActive {
  code: String!
  isValidationError: Boolean!
}

type PromotionCodeNotForCustomer {
  code: String!
  isValidationError: Boolean!
}

type PromotionCodeNotFound {
  code: String!
  isValidationError: Boolean!
}

type StripeCustomerIsDeleted {
  code: String!
  isValidationError: Boolean!
  billingId: String!
}

type UsageMeasurementUpdated {
  currentUsage: Float!
  featureId: String!
  customerId: String!
  resourceId: String
  environmentId: String!
  accountId: String!

  """
  The start date of the usage period that the measurement resides in (for entitlement with reset period)
  """
  usagePeriodStart: Float

  """
  The end date of the usage period that the measurement resides in (for entitlement with reset period)
  """
  usagePeriodEnd: Float
  nextResetDate: Float @deprecated(reason: "renamed to usagePeriodEnd")
}

type UsageUpdated {
  usage: UsageMeasurementUpdated!
  entitlement: Entitlement!
}

type FeatureNotFoundError {
  code: String!
  isValidationError: Boolean!
  refId: String!
}

type MeteringNotAvailableForFeatureTypeError {
  code: String!
  isValidationError: Boolean!
  featureType: String!
}

type UnsupportedVendorIdentifierError {
  code: String!
  vendorIdentifier: String!
}

type IncompatibleSubscriptionAddonError {
  code: String!
  isValidationError: Boolean!
  planDisplayName: String!
  nonCompatibleAddons: [String!]
}

type UnPublishedPackageError {
  code: String!
  isValidationError: Boolean!
  packageType: String!
  nonPublishedPackageIds: [String!]
}

type EditAllowedOnDraftPackageOnlyError {
  code: String!
  isValidationError: Boolean!
}

type FailedToImportCustomerError {
  code: String!
  isValidationError: Boolean!
  billingId: String!
  failedCustomerIds: [String!]!
  failedBillingIds: [String!]!
}

type InitStripePaymentMethodError {
  code: String!
  isValidationError: Boolean!
}

type CannotDeleteCustomerError {
  code: String!
  isValidationError: Boolean!
  refId: String!
}

type ChangingPayingCustomerIsNotSupportedError {
  code: String!
  isValidationError: Boolean!
  currentPayingCustomerId: String!
  newPayingCustomerId: String!
}

type SubscriptionAlreadyCanceledOrExpired {
  code: String!
  isValidationError: Boolean!
  refId: String!
  status: SubscriptionStatus!
}

type InvalidCancellationDate {
  code: String!
  isValidationError: Boolean!
  refId: String!
}

type InvalidSubscriptionStatus {
  code: String!
  isValidationError: Boolean!
}

type AccountNotFoundError {
  code: String!
  isValidationError: Boolean!
}

type DateRange {
  start: DateTime
  end: DateTime
}

type SubscriptionPreviewCredits {
  initial: Money!
  used: Money!
  remaining: Money!
}

type SubscriptionPreviewDiscount {
  """Coupon name"""
  name: String

  """Discount type"""
  type: DiscountType!

  """Coupon value"""
  value: Float!

  """Coupon duration type"""
  durationType: DiscountDurationType!

  """Coupon duration in month"""
  durationInMonths: Float

  """Coupon start date"""
  start: DateTime!

  """Coupon end date"""
  end: DateTime
}

"""The type of the discount"""
enum DiscountType {
  FIXED
  PERCENTAGE
}

"""The type of the discount duration"""
enum DiscountDurationType {
  FOREVER
  REPEATING
  ONCE
}

type SubscriptionPreviewProrations {
  prorationDate: DateTime!
  credit: Money!
  debit: Money!
  netAmount: Money!
  hasProrations: Boolean
}

type SubscriptionPreviewTaxDetails {
  displayName: String!
  percentage: Float!
  inclusive: Boolean!
}

type SubscriptionPricePreviewDTO {
  subTotal: Money!
  totalExcludingTax: Money!
  total: Money!
  tax: Money!
  taxDetails: SubscriptionPreviewTaxDetails
  discountAmount: Money
  discount: SubscriptionPreviewDiscount
}

type SubscriptionPreview {
  subTotal: Money!
  totalExcludingTax: Money!

  """The minimum spend adjustment applied to the invoice"""
  minimumSpendAdjustment: Money!
  total: Money!
  tax: Money
  discountAmount: Money
  taxDetails: SubscriptionPreviewTaxDetails
  discount: SubscriptionPreviewDiscount
  billingPeriodRange: DateRange!
  proration: SubscriptionPreviewProrations
  subscription: SubscriptionPricePreviewDTO
  isPlanDowngrade: Boolean
  hasScheduledUpdates: Boolean
  credits: SubscriptionPreviewCredits
}

type ProvisionSubscriptionResult {
  id: String!
  status: ProvisionSubscriptionStatus!
  checkoutBillingId: String
  checkoutUrl: String
  subscription: CustomerSubscription
  isScheduled: Boolean
  entitlements: [Entitlement!]
}

"""Provision subscription status"""
enum ProvisionSubscriptionStatus {
  PAYMENT_REQUIRED
  SUCCESS
}

type PriceEntitlement {
  description: String
  featureId: String!
  packageId: String!
  updatedAt: DateTime
  usageLimit: Float
  hasSoftLimit: Boolean
  hasUnlimitedUsage: Boolean
  resetPeriod: EntitlementResetPeriod
  resetPeriodConfiguration: ResetPeriodConfiguration
  package: PackageDTO!
  feature: Feature!
}

type EntitlementSummary {
  featurePackageEntitlement: PackageEntitlement
  featurePromotionalEntitlement: PromotionalEntitlement
  priceEntitlement: PriceEntitlement
  addonQuantity: Float
  plan: Plan
  subscription: CustomerSubscription
  isEffectiveEntitlement: Boolean!
}

type EntitlementWithSummary {
  isGranted: Boolean!
  customerId: String @deprecated(reason: "No longer in use")
  resourceId: String @deprecated(reason: "No longer in use")
  accessDeniedReason: AccessDeniedReason
  currentUsage: Float
  requestedUsage: Float
  usageLimit: Float
  hasSoftLimit: Boolean
  hasUnlimitedUsage: Boolean!

  """
  The anchor for calculating the usage period for metered entitlements with a reset period configured
  """
  usagePeriodAnchor: DateTime

  """
  The start date of the usage period for metered entitlements with a reset period configured
  """
  usagePeriodStart: DateTime

  """
  The end date of the usage period for metered entitlements with a reset period configured
  """
  usagePeriodEnd: DateTime
  nextResetDate: DateTime @deprecated(reason: "renamed to usagePeriodEnd")
  usageUpdatedAt: DateTime
  entitlementUpdatedAt: DateTime
  resetPeriod: EntitlementResetPeriod
  resetPeriodConfiguration: ResetPeriodConfiguration
  feature: EntitlementFeature
  meterId: String
  hiddenFromWidgets: [WidgetType!]
  displayNameOverride: String
  summaries: [EntitlementSummary!]
}

"""An object representing the usage charged"""
type UsageCharged {
  """The id of the feature"""
  featureId: String

  """The amount of units charged for usage usage"""
  usageAmount: Float!
}

"""Input for triggering an immediate usage charge for a subscription"""
type ChargeSubscriptionUsage {
  """The subscription reference id for which the usage was charged"""
  subscriptionId: String!

  """The date from which the usage was calculated from"""
  periodStart: DateTime!

  """The date from which the usage was calculated to"""
  periodEnd: DateTime!

  """
  The ID of the invoice in the billing integration. If null then no invoice was created
  """
  invoiceBillingId: String

  """An array of the usage items which were charged"""
  usageCharged: [UsageCharged!]!
}

"""The invoice line item period"""
type SubscriptionInvoicePreviewLineItemPeriod {
  start: DateTime!
  end: DateTime!
}

"""The invoice line item"""
type SubscriptionInvoicePreviewLineItemData {
  """The charge type of the invoice line item"""
  type: InvoiceLineItemType!

  """The description of the invoice line item"""
  description: String!

  """The cost description of the invoice line item"""
  costDescription: String!

  """The total amount of the invoice line item"""
  amount: Money!

  """The unit price of the invoice line item"""
  unitPrice: Money

  """The quantity of the invoice line item"""
  quantity: Int

  """Whether the line item is prorated"""
  proration: Boolean!

  """The price connected to the invoice line item"""
  price: Price

  """The usage limit of the invoice line item"""
  usageLimit: Float
  period: SubscriptionInvoicePreviewLineItemPeriod!

  """Whether the price connected to the invoice line item has a soft limit"""
  hasSoftLimit: Boolean
}

"""The type of the invoice line item"""
enum InvoiceLineItemType {
  AddonCharge
  OverageCharge
  BaseCharge
  InAdvanceCommitmentCharge
  PayAsYouGoCharge
  TierCharge
  MinimumSpendAdjustmentCharge
  MinimumSpendCharge
  ZeroAmountBaseCharge
  Other
}

"""The invoice line item"""
type SubscriptionInvoicePreviewLineItem {
  """The charge type of the invoice line item"""
  type: InvoiceLineItemType!

  """The description of the invoice line item"""
  description: String!

  """The cost description of the invoice line item"""
  costDescription: String!

  """The total amount of the invoice line item"""
  amount: Money!

  """The unit price of the invoice line item"""
  unitPrice: Money

  """The quantity of the invoice line item"""
  quantity: Int

  """Whether the line item is prorated"""
  proration: Boolean!

  """The price connected to the invoice line item"""
  price: Price

  """The usage limit of the invoice line item"""
  usageLimit: Float
  period: SubscriptionInvoicePreviewLineItemPeriod!

  """Whether the price connected to the invoice line item has a soft limit"""
  hasSoftLimit: Boolean

  """The nested line items of the invoice line item"""
  lines: [SubscriptionInvoicePreviewLineItemData!]
}

"""The preview of the next upcoming invoice for the given subscription"""
type SubscriptionInvoicePreview {
  """The amount due for the invoice after taxes, discounts and credits"""
  amountDue: Money!

  """The minimum spend adjustment applied to the invoice"""
  minimumSpendAdjustment: Money!

  """The total amount of the invoice including taxes and discounts"""
  total: Money!

  """The total amount of the invoice excluding taxes"""
  totalExcludingTax: Money!

  """The sub total amount of the invoice excluding  discounts"""
  subTotal: Money!

  """The sub total amount of the invoice excluding taxes and discounts"""
  subTotalExcludingTax: Money!

  """The total tax amount of the invoice"""
  tax: Money

  """The applied tax details"""
  taxDetails: SubscriptionPreviewTaxDetails

  """The total discount amount of the invoice"""
  discount: Money

  """The applied discount details"""
  discountDetails: SubscriptionPreviewDiscount

  """Credits information (initial, used, remaining)"""
  credits: SubscriptionPreviewCredits

  """The date when the invoice was last updated"""
  lastUpdatedAt: DateTime!

  """The line items of the invoice"""
  lines: [SubscriptionInvoicePreviewLineItem!]!
}

type SubscriptionMaximumSpendDiscount {
  """Coupon name"""
  name: String

  """Discount type"""
  type: DiscountType

  """Coupon value"""
  value: Float

  """Coupon duration type"""
  durationType: DiscountDurationType

  """Coupon duration in month"""
  durationInMonths: Float

  """Coupon start date"""
  start: DateTime
}

type SubscriptionMaximumSpend {
  """The maximum spending limit set"""
  maximumSpend: Money!
  total: Money!
  subTotal: Money!
  discount: Money
  discountDetails: SubscriptionMaximumSpendDiscount
  lines: [SubscriptionInvoicePreviewLineItem!]
  lastUpdatedAt: DateTime!
}

type CannotDeleteFeatureError {
  code: String!
  isValidationError: Boolean!
  refId: String!
}

type Hook {
  id: String!
  description: String
  secretKey: String
  endpoint: String!
  status: HookStatus!
  createdAt: DateTime
  environmentId: String!
  eventLogTypes: [EventLogType!]!

  """A JSON containing the configuration for each event log type"""
  configuration: JSON
  account: Account
  environment: Environment
}

"""HookStatus."""
enum HookStatus {
  INACTIVE
  ACTIVE
}

"""EventLogType"""
enum EventLogType {
  CUSTOMER_CREATED
  CUSTOMER_UPDATED
  CUSTOMER_DELETED
  SUBSCRIPTION_CREATED
  SUBSCRIPTION_TRIAL_STARTED
  SUBSCRIPTION_TRIAL_EXPIRED
  SUBSCRIPTION_TRIAL_CONVERTED
  SUBSCRIPTION_TRIAL_ENDS_SOON
  SUBSCRIPTION_UPDATED
  SUBSCRIPTION_CANCELED
  SUBSCRIPTION_EXPIRED
  SUBSCRIPTION_USAGE_UPDATED
  CREATE_SUBSCRIPTION_FAILED
  PLAN_CREATED
  PLAN_UPDATED
  PLAN_DELETED
  ADDON_CREATED
  ADDON_UPDATED
  ADDON_DELETED
  FEATURE_CREATED
  FEATURE_UPDATED
  FEATURE_DELETED
  FEATURE_ARCHIVED
  ENTITLEMENT_REQUESTED
  ENTITLEMENT_GRANTED
  ENTITLEMENT_DENIED
  ENTITLEMENTS_UPDATED
  ENTITLEMENT_USAGE_EXCEEDED
  MEASUREMENT_REPORTED
  PROMOTIONAL_ENTITLEMENT_GRANTED
  PROMOTIONAL_ENTITLEMENT_UPDATED
  PROMOTIONAL_ENTITLEMENT_EXPIRED
  PROMOTIONAL_ENTITLEMENT_REVOKED
  PACKAGE_PUBLISHED
  RESYNC_INTEGRATION_TRIGGERED
  COUPON_CREATED
  COUPON_UPDATED
  COUPON_ARCHIVED
  IMPORT_INTEGRATION_CATALOG_TRIGGERED
  IMPORT_INTEGRATION_CUSTOMERS_TRIGGERED
  SYNC_FAILED
  CUSTOMER_PAYMENT_FAILED
  PRODUCT_CREATED
  PRODUCT_UPDATED
  PRODUCT_DELETED
  PACKAGE_GROUP_CREATED
  PACKAGE_GROUP_UPDATED
  ENVIRONMENT_DELETED
  WIDGET_CONFIGURATION_UPDATED
  EDGE_API_DATA_RESYNC
  EDGE_API_DOGGO_RESYNC
  CUSTOMER_RESOURCE_ENTITLEMENT_CALCULATION_TRIGGERED
  CUSTOMER_ENTITLEMENT_CALCULATION_TRIGGERED
  RECALCULATE_ENTITLEMENTS_TRIGGERED
  IMPORT_SUBSCRIPTIONS_BULK_TRIGGERED
  EDGE_API_CUSTOMER_DATA_RESYNC
  EDGE_API_SUBSCRIPTIONS_DATA_RESYNC
  EDGE_API_PACKAGE_ENTITLEMENTS_DATA_RESYNC
  SUBSCRIPTIONS_MIGRATED
  SUBSCRIPTIONS_MIGRATION_TRIGGERED
  SUBSCRIPTION_BILLING_MONTH_ENDS_SOON
  SUBSCRIPTION_USAGE_CHARGE_TRIGGERED
  SUBSCRIPTION_SPENT_LIMIT_EXCEEDED
}

type TestHook {
  testHookEventType: String!
  testHookPayload: String!
}

type TestHookResult {
  responseStatusCode: Float
  responseStatusText: String
  responseSuccess: Boolean!
}

type HookDeleteResponse {
  id: String
  description: String
  secretKey: String
  endpoint: String
  status: HookStatus
  createdAt: DateTime
  environmentId: String
  eventLogTypes: [EventLogType!]

  """A JSON containing the configuration for each event log type"""
  configuration: JSON
}

type HookEdge {
  """The node containing the Hook"""
  node: Hook!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

type PageInfo {
  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor

  """The cursor of the last returned record."""
  endCursor: ConnectionCursor
}

type HookConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [HookEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type HookAggregateGroupBy {
  id: String
  endpoint: String
  status: HookStatus
  createdAt: DateTime
  environmentId: String
}

type HookCountAggregate {
  id: Int
  endpoint: Int
  status: Int
  createdAt: Int
  environmentId: Int
}

type HookMinAggregate {
  id: String
  endpoint: String
  status: HookStatus
  createdAt: DateTime
  environmentId: String
}

type HookMaxAggregate {
  id: String
  endpoint: String
  status: HookStatus
  createdAt: DateTime
  environmentId: String
}

type CouponEdge {
  """The node containing the Coupon"""
  node: Coupon!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type CouponConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [CouponEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type CouponAggregateGroupBy {
  id: String
  name: String
  refId: String
  description: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
  type: CouponType
  status: CouponStatus
  source: CouponSource
  billingId: String
}

type CouponCountAggregate {
  id: Int
  name: Int
  refId: Int
  description: Int
  createdAt: Int
  updatedAt: Int
  environmentId: Int
  type: Int
  status: Int
  source: Int
  billingId: Int
}

type CouponMinAggregate {
  id: String
  name: String
  refId: String
  description: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
  type: CouponType
  status: CouponStatus
  source: CouponSource
  billingId: String
}

type CouponMaxAggregate {
  id: String
  name: String
  refId: String
  description: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
  type: CouponType
  status: CouponStatus
  source: CouponSource
  billingId: String
}

type Member {
  id: String!
  createdAt: DateTime
  memberStatus: MemberStatus!
  email: String!
  serviceApiKey: String
  cubejsToken: String
  customerToken: String
  hideGettingStartedPage: Boolean

  """The id of the user associated with this member"""
  userId: String!

  """Get the access roles assigned to the member"""
  accessRoles: AccessRoles
  user: User
  account: Account!
}

"""Member Status."""
enum MemberStatus {
  INVITED
  REGISTERED
}

type User {
  id: String!
  email: String
  name: String
  profileImageUrl: String
  lastSeenAt: DateTime
  memberships: [Member!]!
  department: Department

  """Intercom user identity token"""
  intercomToken: String
}

enum Department {
  ENGINEERING
  PRODUCT
  GROWTH
  MARKETING
  MONETIZATION
  CEO_OR_FOUNDER
  OTHER
}

type PackagePricingTypeNotSetError {
  code: String!
  isValidationError: Boolean!
  refId: String!
}

type PackageAlreadyPublishedError {
  code: String!
  isValidationError: Boolean!
}

type PublishPackageResult {
  taskId: String
}

type TriggerSubscriptionMigrationResult {
  taskId: String
}

type InvalidEntitlementResetPeriodError {
  code: String!
  isValidationError: Boolean!
}

type ValidateMergeEnvironment {
  errors: [String!]!
  isValid: Boolean!
}

type DumpEnvironmentForMergeComparison {
  preMergeDump: JSON!
  postMergeDump: JSON!
}

type MergeEnvironment {
  environmentSlug: String!
  taskIds: [String!]!
}

type ProductCatalogDump {
  dump: JSON!
}

type ProductDeleteResponse {
  id: String
  displayName: String
  refId: String
  description: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
  isDefaultProduct: Boolean
  plans: [Plan!]
  addons: [Addon!]
  productSettings: ProductSettings
  multipleSubscriptions: Boolean
  additionalMetaData: JSON
  awsMarketplaceProductId: String
  awsMarketplaceProductCode: String
}

type RecalculateEntitlementsResult {
  taskId: String!
}

type SubscriptionMigrationTask {
  id: String!
  environmentId: String!
  createdAt: DateTime
  taskType: TaskType!
  status: TaskStatus!
  startDate: DateTime
  endDate: DateTime
  progress: Int!
  initiatedPackageId: String
  affectedCustomersCount: Int
  migratedCustomersCount: Int
  packages(
    """Specify to filter the records returned."""
    filter: PackageDTOFilter = {}

    """Specify to sort results."""
    sorting: [PackageDTOSort!] = [{field: createdAt, direction: DESC}]
  ): [PackageDTO!]!
}

enum TaskType {
  SUBSCRIPTION_MIGRATION
  SUBSCRIPTION_MIGRATION_V2
  RESYNC_INTEGRATION
  IMPORT_INTEGRATION_CATALOG
  IMPORT_INTEGRATION_CUSTOMERS
  RECALCULATE_ENTITLEMENTS
  RECALCULATE_BATCH_ENTITLEMENTS
  IMPORT_SUBSCRIPTIONS_BULK
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  PARTIALLY_FAILED
  FAILED
  CANCELED
}

input PackageDTOFilter {
  and: [PackageDTOFilter!]
  or: [PackageDTOFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  refId: StringFieldComparison
  billingId: StringFieldComparison
  displayName: StringFieldComparison
  status: PackageStatusFilterComparison
  pricingType: PricingTypeFilterComparison
  description: StringFieldComparison
  environmentId: StringFieldComparison
  productId: StringFieldComparison
  isLatest: BooleanFieldComparison
  versionNumber: IntFieldComparison
}

input PackageDTOSort {
  field: PackageDTOSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PackageDTOSortFields {
  id
  createdAt
  updatedAt
  refId
  billingId
  displayName
  status
  pricingType
  description
  environmentId
  productId
  isLatest
  versionNumber
}

type ImportSubTaskError {
  id: String!
  error: String!
}

type ImportIntegrationTask {
  id: String!
  environmentId: String!
  createdAt: DateTime
  taskType: TaskType!
  status: TaskStatus!
  startDate: DateTime
  endDate: DateTime
  progress: Int!
  productsCount: Int!
  customersCount: Int!
  totalSubtasksCount: Int!
  importErrors: [ImportSubTaskError!]!
}

type SubscriptionMigrationTaskEdge {
  """The node containing the SubscriptionMigrationTask"""
  node: SubscriptionMigrationTask!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type SubscriptionMigrationTaskConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [SubscriptionMigrationTaskEdge!]!
}

type SubscriptionMigrationTaskAggregateGroupBy {
  id: String
  environmentId: String
  createdAt: DateTime
  taskType: TaskType
  status: TaskStatus
}

type SubscriptionMigrationTaskCountAggregate {
  id: Int
  environmentId: Int
  createdAt: Int
  taskType: Int
  status: Int
}

type SubscriptionMigrationTaskMinAggregate {
  id: String
  environmentId: String
  createdAt: DateTime
  taskType: TaskType
  status: TaskStatus
}

type SubscriptionMigrationTaskMaxAggregate {
  id: String
  environmentId: String
  createdAt: DateTime
  taskType: TaskType
  status: TaskStatus
}

type ImportIntegrationTaskEdge {
  """The node containing the ImportIntegrationTask"""
  node: ImportIntegrationTask!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type ImportIntegrationTaskConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [ImportIntegrationTaskEdge!]!
}

type ImportIntegrationTaskAggregateGroupBy {
  id: String
  environmentId: String
  createdAt: DateTime
  taskType: TaskType
  status: TaskStatus
}

type ImportIntegrationTaskCountAggregate {
  id: Int
  environmentId: Int
  createdAt: Int
  taskType: Int
  status: Int
}

type ImportIntegrationTaskMinAggregate {
  id: String
  environmentId: String
  createdAt: DateTime
  taskType: TaskType
  status: TaskStatus
}

type ImportIntegrationTaskMaxAggregate {
  id: String
  environmentId: String
  createdAt: DateTime
  taskType: TaskType
  status: TaskStatus
}

type UpdateEntitlementsOrderDTO {
  id: String!
  order: Float
}

type PackageEntitlementDeleteResponse {
  id: String
  description: String
  featureId: String
  packageId: String
  createdAt: DateTime
  updatedAt: DateTime
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  isCustom: Boolean
  environmentId: String
  resetPeriod: EntitlementResetPeriod
  resetPeriodConfiguration: ResetPeriodConfiguration
  order: Float
  hiddenFromWidgets: [WidgetType!]
  displayNameOverride: String

  """The behavior of the entitlement"""
  behavior: EntitlementBehavior
}

type PackageEntitlementEdge {
  """The node containing the PackageEntitlement"""
  node: PackageEntitlement!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type PackageEntitlementConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [PackageEntitlementEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type PackageEntitlementAggregateGroupBy {
  id: String
  packageId: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
}

type PackageEntitlementCountAggregate {
  id: Int
  packageId: Int
  createdAt: Int
  updatedAt: Int
  environmentId: Int
}

type PackageEntitlementMinAggregate {
  id: String
  packageId: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
}

type PackageEntitlementMaxAggregate {
  id: String
  packageId: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
}

type PromotionalEntitlementDeleteResponse {
  id: String
  description: String
  featureId: String
  createdAt: DateTime
  updatedAt: DateTime
  startDate: DateTime
  endDate: DateTime
  isVisible: Boolean
  usageLimit: Float
  hasSoftLimit: Boolean
  hasUnlimitedUsage: Boolean
  unlimited: Boolean
  status: PromotionalEntitlementStatus
  period: PromotionalEntitlementPeriod
  resetPeriod: EntitlementResetPeriod
  resetPeriodConfiguration: ResetPeriodConfiguration
  environmentId: String
}

type PromotionalEntitlementEdge {
  """The node containing the PromotionalEntitlement"""
  node: PromotionalEntitlement!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type PromotionalEntitlementConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [PromotionalEntitlementEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type PromotionalEntitlementAggregateGroupBy {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  status: PromotionalEntitlementStatus
  environmentId: String
}

type PromotionalEntitlementCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  status: Int
  environmentId: Int
}

type PromotionalEntitlementMinAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  status: PromotionalEntitlementStatus
  environmentId: String
}

type PromotionalEntitlementMaxAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  status: PromotionalEntitlementStatus
  environmentId: String
}

type SubscriptionEntitlementEdge {
  """The node containing the SubscriptionEntitlement"""
  node: SubscriptionEntitlement!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type SubscriptionEntitlementConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [SubscriptionEntitlementEdge!]!
}

type SubscriptionEntitlementAggregateGroupBy {
  id: String
  subscriptionId: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
}

type SubscriptionEntitlementCountAggregate {
  id: Int
  subscriptionId: Int
  createdAt: Int
  updatedAt: Int
  environmentId: Int
}

type SubscriptionEntitlementMinAggregate {
  id: String
  subscriptionId: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
}

type SubscriptionEntitlementMaxAggregate {
  id: String
  subscriptionId: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
}

type PaywallColorsPalette {
  primary: String
  textColor: String
  backgroundColor: String
  borderColor: String
  currentPlanBackground: String
}

type PaywallLayoutConfiguration {
  alignment: Alignment
  planWidth: Float
  planMargin: Float
  planPadding: Float
}

"""Alignment"""
enum Alignment {
  LEFT
  CENTER
  RIGHT
}

type FontVariant {
  fontSize: Float
  fontWeight: FontWeight
}

"""Font weight"""
enum FontWeight {
  NORMAL
  BOLD
}

type TypographyConfiguration {
  fontFamily: String
  h1: FontVariant
  h2: FontVariant
  h3: FontVariant
  body: FontVariant
}

type PaywallConfiguration {
  palette: PaywallColorsPalette
  typography: TypographyConfiguration
  layout: PaywallLayoutConfiguration
  customCss: String
}

type PaywallCurrency {
  code: Currency!
  symbol: String!
}

type PaywallPricePoint {
  planId: String!
  additionalChargesMayApply: Boolean
  billingPeriod: BillingPeriod!
  amount: Float!
  currency: Currency!
  billingCountryCode: String
  feature: Feature
}

type Paywall {
  plans: [Plan!]!
  configuration: PaywallConfiguration
  customer: Customer
  resource: CustomerResource
  activeSubscriptions: [CustomerSubscription!]
  currency: PaywallCurrency!
  paywallCalculatedPricePoints: [PaywallPricePoint!]
}

type PaywallProduct {
  refId: String!
  displayName: String
  description: String
  additionalMetaData: JSON
}

type PaywallBasePlan {
  refId: String!
  displayName: String!
}

type PaywallPrice {
  billingPeriod: BillingPeriod!
  billingModel: BillingModel!
  billingId: String
  price: Money
  tiersMode: TiersMode
  tiers: [PriceTier!]
  billingCountryCode: String
  featureId: String
  minUnitQuantity: Float
  maxUnitQuantity: Float
  feature: EntitlementFeature

  """The number of units per block. Defaults to 1 unit."""
  blockSize: Float
}

type PaywallAddon {
  refId: String!
  description: String
  billingId: String
  displayName: String!
  additionalMetaData: JSON
  entitlements: [Entitlement!]!
  prices: [PaywallPrice!]!
  pricingType: PricingType

  """The maximum quantity of this addon that can be added to a subscription"""
  maxQuantity: Float

  """List of addons this addon is dependant on"""
  dependencies: [PaywallAddon!]
}

"""Plan compatible package group options"""
type PaywallPlanCompatiblePackageGroupOptions {
  """Number of required items from packageGroup"""
  minItems: Float

  """Number of free items from package group"""
  freeItems: Float
}

type PaywallPlanCompatiblePackageGroup {
  """The id of the package group"""
  packageGroupId: String!

  """The description of the package group"""
  description: String

  """The display name of the package group"""
  displayName: String!

  """Included addons in the package group"""
  addons: [PaywallAddon!]

  """Plan compatible package group options"""
  options: PaywallPlanCompatiblePackageGroupOptions!
}

type PaywallPlan {
  refId: String!
  description: String
  displayName: String!
  billingId: String
  additionalMetaData: JSON
  product: PaywallProduct!
  basePlan: PaywallBasePlan
  defaultTrialConfig: DefaultTrialConfig
  compatibleAddons: [PaywallAddon!]

  """Plan's compatible package groups"""
  compatiblePackageGroups: [PaywallPlanCompatiblePackageGroup!]
  prices: [PaywallPrice!]!
  pricingType: PricingType
  inheritedEntitlements: [Entitlement!]
  entitlements: [Entitlement!]

  """Minimum spend configuration"""
  minimumSpend: [MinimumSpend!]
}

type MockPaywall {
  plans: [PaywallPlan!]!
  configuration: PaywallConfiguration
}

"""Plan compatible package group options"""
type PlanCompatiblePackageGroupOptions {
  """Number of required items from package group"""
  minItems: Float

  """Number of free items from package group"""
  freeItems: Float
}

"""Plan compatible package group"""
type PlanCompatiblePackageGroups {
  """The display name of the package group"""
  displayName: String!

  """The description of the package group"""
  description: String

  """The id of the package group"""
  packageGroupId: String!

  """The date the package group was created"""
  createdAt: DateTime!

  """The date the package group was last updated"""
  updatedAt: DateTime!

  """The environment id of the package group in"""
  environmentId: String!

  """Indicates if this is the latest version of the package group"""
  isLatest: Boolean!

  """The version number of the package group"""
  versionNumber: Int!

  """The status of the package group"""
  status: PackageGroupStatus!
  productId: String
  product: Product!

  """The addons that are a part of this group"""
  addons: [Addon!]

  """Plan compatible package group options"""
  options: PlanCompatiblePackageGroupOptions!
}

"""List of plans associated with an addon"""
type AddonAssociatedPlan {
  """Plan refId"""
  refId: String!

  """Plan display name"""
  displayName: String!

  """Plan status"""
  status: PackageStatus!

  """Plan version"""
  versionNumber: Float!
}

"""List of package groups associated with an addon"""
type AddonAssociatedPackageGroup {
  """Package group id"""
  packageGroupId: String!

  """Package group display name"""
  displayName: String!
}

"""List of active entities associated with an addon"""
type AddonAssociatedEntities {
  """List of published or draft plans"""
  plans: [AddonAssociatedPlan!]!

  """List of package groups that have this addon"""
  packageGroups: [AddonAssociatedPackageGroup!]!
}

type PackagePrice {
  packageId: String!
  pricingType: PricingType!
}

type FeatureEdge {
  """The node containing the Feature"""
  node: Feature!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type FeatureConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [FeatureEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type FeatureAggregateGroupBy {
  id: String
  displayName: String
  refId: String
  createdAt: DateTime
  updatedAt: DateTime
  description: String
  featureType: FeatureType
  meterType: MeterType
  featureStatus: FeatureStatus
  environmentId: String
}

type FeatureCountAggregate {
  id: Int
  displayName: Int
  refId: Int
  createdAt: Int
  updatedAt: Int
  description: Int
  featureType: Int
  meterType: Int
  featureStatus: Int
  environmentId: Int
}

type FeatureMinAggregate {
  id: String
  displayName: String
  refId: String
  createdAt: DateTime
  updatedAt: DateTime
  description: String
  featureType: FeatureType
  meterType: MeterType
  featureStatus: FeatureStatus
  environmentId: String
}

type FeatureMaxAggregate {
  id: String
  displayName: String
  refId: String
  createdAt: DateTime
  updatedAt: DateTime
  description: String
  featureType: FeatureType
  meterType: MeterType
  featureStatus: FeatureStatus
  environmentId: String
}

type PriceDeleteResponse {
  id: String
  createdAt: DateTime
  environmentId: String
  billingPeriod: BillingPeriod
  billingModel: BillingModel
  billingCadence: BillingCadence
  tiersMode: TiersMode
  tiers: [PriceTier!]
  billingId: String
  price: Money

  """The number of units per block. Defaults to 1 unit."""
  blockSize: Float
  billingCountryCode: String
  featureId: String
  minUnitQuantity: Float
  packageId: String
  maxUnitQuantity: Float
  feature: Feature
  crmId: String
  crmLinkUrl: String
  usedInSubscriptions: Boolean
  resetPeriod: EntitlementResetPeriod
  resetPeriodConfiguration: ResetPeriodConfiguration
}

type PriceEdge {
  """The node containing the Price"""
  node: Price!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type PriceAggregateGroupBy {
  id: String
  createdAt: DateTime
  billingPeriod: BillingPeriod
  billingModel: BillingModel
  billingCadence: BillingCadence
  tiersMode: TiersMode
  billingId: String
}

type PriceCountAggregate {
  id: Int
  createdAt: Int
  billingPeriod: Int
  billingModel: Int
  billingCadence: Int
  tiersMode: Int
  billingId: Int
}

type PriceMinAggregate {
  id: String
  createdAt: DateTime
  billingPeriod: BillingPeriod
  billingModel: BillingModel
  billingCadence: BillingCadence
  tiersMode: TiersMode
  billingId: String
}

type PriceMaxAggregate {
  id: String
  createdAt: DateTime
  billingPeriod: BillingPeriod
  billingModel: BillingModel
  billingCadence: BillingCadence
  tiersMode: TiersMode
  billingId: String
}

type ExperimentStats {
  controlSubscriptions: Float!
  controlPaidSubscriptions: Float!
  variantSubscriptions: Float!
  variantPaidSubscriptions: Float!
}

type ExperimentEdge {
  """The node containing the Experiment"""
  node: Experiment!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type ExperimentConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [ExperimentEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ExperimentAggregateGroupBy {
  id: String
  name: String
  refId: String
  createdAt: DateTime
  environmentId: String
  productId: String
  status: ExperimentStatus
}

type ExperimentCountAggregate {
  id: Int
  name: Int
  refId: Int
  createdAt: Int
  environmentId: Int
  productId: Int
  status: Int
}

type ExperimentSumAggregate {
  id: Float
}

type ExperimentAvgAggregate {
  id: Float
}

type ExperimentMinAggregate {
  id: String
  name: String
  refId: String
  createdAt: DateTime
  environmentId: String
  productId: String
  status: ExperimentStatus
}

type ExperimentMaxAggregate {
  id: String
  name: String
  refId: String
  createdAt: DateTime
  environmentId: String
  productId: String
  status: ExperimentStatus
}

type CustomerPortalColorsPalette {
  primary: String
  textColor: String
  backgroundColor: String
  paywallBackgroundColor: String
  borderColor: String
  currentPlanBackground: String
  iconsColor: String
}

type CustomerPortalConfiguration {
  palette: CustomerPortalColorsPalette
  typography: TypographyConfiguration
  customCss: String
}

type CheckoutColorPalette {
  primary: String
  textColor: String
  backgroundColor: String
  borderColor: String
  summaryBackgroundColor: String
}

type CheckoutContent {
  collectPhoneNumber: Boolean
}

type CheckoutConfiguration {
  palette: CheckoutColorPalette
  typography: TypographyConfiguration
  customCss: String
  content: CheckoutContent
}

type WidgetConfiguration {
  customerPortal: CustomerPortalConfiguration
  paywall: PaywallConfiguration
  checkout: CheckoutConfiguration
}

type SdkConfiguration {
  sentryDsn: String
  isWidgetWatermarkEnabled: Boolean
}

type PackagePublished {
  accountId: String!
  environmentId: String!
  packageType: String!
  packageRefId: String!
  packageVersion: Int!
  migrationType: PublishMigrationType!
}

"""PublishMigrationType"""
enum PublishMigrationType {
  NEW_CUSTOMERS
  ALL_CUSTOMERS
}

type PlanEdge {
  """The node containing the Plan"""
  node: Plan!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type PlanConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [PlanEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type PlanAggregateGroupBy {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  refId: String
  billingId: String
  displayName: String
  status: PackageStatus
  pricingType: PricingType
  description: String
  environmentId: String
  productId: String
  isLatest: Boolean
  versionNumber: Int
}

type PlanCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  refId: Int
  billingId: Int
  displayName: Int
  status: Int
  pricingType: Int
  description: Int
  environmentId: Int
  productId: Int
  isLatest: Int
  versionNumber: Int
}

type PlanSumAggregate {
  versionNumber: Float
}

type PlanAvgAggregate {
  versionNumber: Float
}

type PlanMinAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  refId: String
  billingId: String
  displayName: String
  status: PackageStatus
  pricingType: PricingType
  description: String
  environmentId: String
  productId: String
  versionNumber: Int
}

type PlanMaxAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  refId: String
  billingId: String
  displayName: String
  status: PackageStatus
  pricingType: PricingType
  description: String
  environmentId: String
  productId: String
  versionNumber: Int
}

type AddonEdge {
  """The node containing the Addon"""
  node: Addon!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type AddonConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [AddonEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type AddonAggregateGroupBy {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  refId: String
  billingId: String
  displayName: String
  status: PackageStatus
  pricingType: PricingType
  description: String
  environmentId: String
  productId: String
  isLatest: Boolean
  versionNumber: Int
}

type AddonCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  refId: Int
  billingId: Int
  displayName: Int
  status: Int
  pricingType: Int
  description: Int
  environmentId: Int
  productId: Int
  isLatest: Int
  versionNumber: Int
}

type AddonSumAggregate {
  versionNumber: Float
}

type AddonAvgAggregate {
  versionNumber: Float
}

type AddonMinAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  refId: String
  billingId: String
  displayName: String
  status: PackageStatus
  pricingType: PricingType
  description: String
  environmentId: String
  productId: String
  versionNumber: Int
}

type AddonMaxAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  refId: String
  billingId: String
  displayName: String
  status: PackageStatus
  pricingType: PricingType
  description: String
  environmentId: String
  productId: String
  versionNumber: Int
}

type ProductEdge {
  """The node containing the Product"""
  node: Product!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type ProductConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [ProductEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type ProductAggregateGroupBy {
  id: String
  displayName: String
  refId: String
  description: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
  isDefaultProduct: Boolean
  multipleSubscriptions: Boolean
  awsMarketplaceProductId: String
  awsMarketplaceProductCode: String
}

type ProductCountAggregate {
  id: Int
  displayName: Int
  refId: Int
  description: Int
  createdAt: Int
  updatedAt: Int
  environmentId: Int
  isDefaultProduct: Int
  multipleSubscriptions: Int
  awsMarketplaceProductId: Int
  awsMarketplaceProductCode: Int
}

type ProductMinAggregate {
  id: String
  displayName: String
  refId: String
  description: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
  awsMarketplaceProductId: String
  awsMarketplaceProductCode: String
}

type ProductMaxAggregate {
  id: String
  displayName: String
  refId: String
  description: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
  awsMarketplaceProductId: String
  awsMarketplaceProductCode: String
}

type PackageGroupEdge {
  """The node containing the PackageGroup"""
  node: PackageGroup!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type PackageGroupConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [PackageGroupEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type PackageGroupAggregateGroupBy {
  displayName: String
  packageGroupId: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
  isLatest: Boolean
  versionNumber: Int
  status: PackageGroupStatus
  productId: String
}

type PackageGroupCountAggregate {
  displayName: Int
  packageGroupId: Int
  createdAt: Int
  updatedAt: Int
  environmentId: Int
  isLatest: Int
  versionNumber: Int
  status: Int
  productId: Int
}

type PackageGroupSumAggregate {
  versionNumber: Float
}

type PackageGroupAvgAggregate {
  versionNumber: Float
}

type PackageGroupMinAggregate {
  displayName: String
  packageGroupId: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
  versionNumber: Int
  status: PackageGroupStatus
  productId: String
}

type PackageGroupMaxAggregate {
  displayName: String
  packageGroupId: String
  createdAt: DateTime
  updatedAt: DateTime
  environmentId: String
  versionNumber: Int
  status: PackageGroupStatus
  productId: String
}

type EnvironmentEdge {
  """The node containing the Environment"""
  node: Environment!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type EnvironmentConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [EnvironmentEdge!]!
}

type EnvironmentAggregateGroupBy {
  id: String
  createdAt: DateTime
  displayName: String
  slug: String
  permanentDeletionDate: DateTime
}

type EnvironmentCountAggregate {
  id: Int
  createdAt: Int
  displayName: Int
  slug: Int
  permanentDeletionDate: Int
}

type EnvironmentMinAggregate {
  id: String
  createdAt: DateTime
  displayName: String
  slug: String
  permanentDeletionDate: DateTime
}

type EnvironmentMaxAggregate {
  id: String
  createdAt: DateTime
  displayName: String
  slug: String
  permanentDeletionDate: DateTime
}

type ResyncIntegrationResult {
  """ID of the task associated with the re-sync operation"""
  taskId: String

  """ID of the integration that was re-synced"""
  integrationId: String!
}

type ImportAlreadyInProgressError {
  code: String!
  isValidationError: Boolean!
}

type StripeProductPrice {
  amount: Float!
  billingPeriod: BillingPeriod
}

type StripeProduct {
  id: String!
  name: String!
  prices: [StripeProductPrice!]!
  notSupportedForImport: Boolean!
  updatedAt: DateTime!
  isSynced: Boolean!
  environmentId: String
}

type StripeProductSearchResult {
  products: [StripeProduct!]!
  totalCount: Int!
  nextPage: String
  usageBasedProductPresent: Boolean
}

type StripeCustomer {
  id: String!
  name: String!
  email: String!
  subscriptionsCount: Float!
  subscriptionPlanName: String
  createdAt: DateTime!
  isSynced: Boolean!
  environmentId: String
}

type StripeCustomerSearchResult {
  customers: [StripeCustomer!]!
  totalCount: Int!
  nextPage: String
}

type StripeSubscription {
  id: String!
}

type StripeSubscriptionSearchResult {
  subscriptions: [StripeSubscription!]!
  totalCount: Int!
  nextPage: String
}

type AsyncTaskResult {
  taskId: String!
}

type AwsProduct {
  productId: String!
  title: String!
  productCode: String!
  description: String!
  visibility: String!
  logoUrl: String
  stiggProductId: String
  stiggProductRefId: String
}

type ListAwsProductsResult {
  products: [AwsProduct!]!
}

type GetAwsExternalIdResult {
  externalId: String!
}

type AwsDimension {
  name: String!
  description: String!
  key: String!
  unit: String!
  type: String!
  stiggPlanName: String
  stiggPlanId: String
}

type ListAwsProductDimensionsDTO {
  dimensions: [AwsDimension!]!
}

type IntegrationDeleteResponse {
  id: String
  createdAt: DateTime
  environmentId: String
  vendorIdentifier: VendorIdentifier

  """The vendor type"""
  vendorType: VendorType

  """Whether the integration is the default"""
  isDefault: Boolean

  """The reference ID for the integration"""
  integrationId: String
  credentials: Credentials
}

type IntegrationEdge {
  """The node containing the Integration"""
  node: Integration!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type IntegrationConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [IntegrationEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type IntegrationAggregateGroupBy {
  id: String
  createdAt: DateTime
  environmentId: String
  vendorIdentifier: VendorIdentifier
  vendorType: VendorType
}

type IntegrationCountAggregate {
  id: Int
  createdAt: Int
  environmentId: Int
  vendorIdentifier: Int
  vendorType: Int
}

type IntegrationMinAggregate {
  id: String
  createdAt: DateTime
  environmentId: String
  vendorIdentifier: VendorIdentifier
  vendorType: VendorType
}

type IntegrationMaxAggregate {
  id: String
  createdAt: DateTime
  environmentId: String
  vendorIdentifier: VendorIdentifier
  vendorType: VendorType
}

type InitAddStripeCustomerPaymentMethod {
  paymentIntentClientSecret: String!
}

type ProvisionedCustomer {
  customer: Customer!
  subscriptionStrategyDecision: SubscriptionDecisionStrategy! @deprecated(reason: "this field was renamed to 'subscriptionDecisionStrategy'")
  subscriptionDecisionStrategy: SubscriptionDecisionStrategy!
  subscription: CustomerSubscription
  entitlements: [Entitlement!]
}

"""Subscription decision strategy"""
enum SubscriptionDecisionStrategy {
  PREDEFINED_FREE_PLAN
  PREDEFINED_TRIAL_PLAN
  REQUESTED_PLAN
  SKIPPED_SUBSCRIPTION_CREATION
}

type CustomerPortalBillingInformation {
  name: String
  email: String
  defaultPaymentMethodId: String
  defaultPaymentMethodType: PaymentMethodType
  defaultPaymentMethodLast4Digits: String
  defaultPaymentExpirationMonth: Int
  defaultPaymentExpirationYear: Int
}

type CustomerPortalPromotionalEntitlement {
  displayName: String!
  description: String
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  startDate: DateTime!
  endDate: DateTime
  period: PromotionalEntitlementPeriod!
}

type CustomerPortalPricingFeature {
  id: String!
  displayName: String!
  refId: String!
  featureUnits: String
  featureUnitsPlural: String
  description: String
  featureType: FeatureType!
  meterType: MeterType
}

type CustomerPortalAddon {
  addonId: String!
  displayName: String!
  description: String
  quantity: Int!
}

type CustomerPortalSubscriptionPricing {
  pricingType: PricingType!
  unitQuantity: Int
  billingPeriod: BillingPeriod
  billingModel: BillingModel
  price: Money
  billingCountryCode: String
  feature: CustomerPortalPricingFeature
  usageBasedEstimatedBill: Float
}

type CustomerPortalSubscriptionPrice {
  billingPeriod: BillingPeriod
  billingModel: BillingModel
  price: Money

  """The number of units per block"""
  blockSize: Float
  feature: CustomerPortalPricingFeature
}

type CustomerPortalSubscription {
  subscriptionId: String!
  planId: String!
  planName: String!
  pricingType: PricingType!
  prices: [CustomerPortalSubscriptionPrice!]!
  pricing: CustomerPortalSubscriptionPricing! @deprecated(reason: "use prices field instead")
  status: SubscriptionStatus!
  totalPrice: CustomerSubscriptionTotalPrice
  billingPeriodRange: DateRange
  trialRemainingDays: Int
  addons: [CustomerPortalAddon!]!
  scheduledUpdates: [SubscriptionScheduledUpdate!]
}

type CustomerPortal {
  subscriptions: [CustomerPortalSubscription!]!
  entitlements: [Entitlement!]!
  promotionalEntitlements: [CustomerPortalPromotionalEntitlement!]!
  billingInformation: CustomerPortalBillingInformation!
  showWatermark: Boolean!
  canUpgradeSubscription: Boolean!
  billingPortalUrl: String
  configuration: CustomerPortalConfiguration
  resource: CustomerResource
}

type PreparedPaymentMethodForm {
  vendorIdentifier: VendorIdentifier!

  """The integration id of the payment method"""
  integrationId: String!
  paymentMethodForm: PaymentMethodForm!
}

union PaymentMethodForm = StripePaymentMethodForm | ZuoraPaymentMethodForm

type StripePaymentMethodForm {
  clientSecret: String!
  stripePublishableKey: String
}

type ZuoraPaymentMethodForm {
  signature: String!
  token: String!
  tenantId: String!
  key: String!
  pageId: String!
  pageUrl: String!
}

type CustomerEdge {
  """The node containing the Customer"""
  node: Customer!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type CustomerConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [CustomerEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type CustomerAggregateGroupBy {
  id: String
  name: String
  email: String
  refId: String
  customerId: String
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  environmentId: String
  billingId: String
  crmId: String
  crmHubspotCompanyId: String
  crmHubspotCompanyUrl: String
  searchQuery: String
}

type CustomerCountAggregate {
  id: Int
  name: Int
  email: Int
  refId: Int
  customerId: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  environmentId: Int
  billingId: Int
  crmId: Int
  crmHubspotCompanyId: Int
  crmHubspotCompanyUrl: Int
  searchQuery: Int
}

type CustomerMinAggregate {
  id: String
  name: String
  email: String
  refId: String
  customerId: String
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  environmentId: String
  billingId: String
  crmId: String
  crmHubspotCompanyId: String
  crmHubspotCompanyUrl: String
  searchQuery: String
}

type CustomerMaxAggregate {
  id: String
  name: String
  email: String
  refId: String
  customerId: String
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  environmentId: String
  billingId: String
  crmId: String
  crmHubspotCompanyId: String
  crmHubspotCompanyUrl: String
  searchQuery: String
}

type CustomerResourceEdge {
  """The node containing the CustomerResource"""
  node: CustomerResource!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type CustomerResourceConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [CustomerResourceEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type CustomerResourceAggregateGroupBy {
  environmentId: String
  resourceId: String
  createdAt: DateTime
}

type CustomerResourceCountAggregate {
  environmentId: Int
  resourceId: Int
  createdAt: Int
}

type CustomerResourceMinAggregate {
  environmentId: String
  resourceId: String
  createdAt: DateTime
}

type CustomerResourceMaxAggregate {
  environmentId: String
  resourceId: String
  createdAt: DateTime
}

type SubscriptionPreviewInvoice {
  total: Money!
  subTotal: Money!
  totalExcludingTax: Money!

  """The minimum spend adjustment applied to the invoice"""
  minimumSpendAdjustment: Money!
  tax: Money
  discount: Money
  taxDetails: SubscriptionPreviewTaxDetails
  discountDetails: SubscriptionPreviewDiscount
}

type ImmediateSubscriptionPreviewInvoice {
  total: Money!
  subTotal: Money!
  totalExcludingTax: Money!

  """The minimum spend adjustment applied to the invoice"""
  minimumSpendAdjustment: Money!
  tax: Money
  discount: Money
  taxDetails: SubscriptionPreviewTaxDetails
  discountDetails: SubscriptionPreviewDiscount
  proration: SubscriptionPreviewProrations
  credits: SubscriptionPreviewCredits
}

type SubscriptionPreviewV2 {
  immediateInvoice: ImmediateSubscriptionPreviewInvoice!
  recurringInvoice: SubscriptionPreviewInvoice
  billingPeriodRange: DateRange!
  isPlanDowngrade: Boolean
  hasScheduledUpdates: Boolean

  """Free items of the subscription"""
  freeItems: [FreeSubscriptionItem!]
}

type ApplySubscription {
  subscription: CustomerSubscription
  entitlements: [Entitlement!]
}

type CheckoutCredentials {
  accountId: String!
  publicKey: String!
}

type CheckoutBillingIntegration {
  billingIdentifier: BillingVendorIdentifier!
  credentials: CheckoutCredentials!
}

"""Billing vendor identifiers"""
enum BillingVendorIdentifier {
  """Stripe billing vendor"""
  STRIPE
}

type CheckoutState {
  configuration: CheckoutConfiguration
  customer: Customer!
  setupSecret: String!
  resource: CustomerResource
  activeSubscription: CustomerSubscription
  plan: Plan!
  billingIntegration: CheckoutBillingIntegration!
}

type CustomerSubscriptionEdge {
  """The node containing the CustomerSubscription"""
  node: CustomerSubscription!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type CustomerSubscriptionConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [CustomerSubscriptionEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type CustomerSubscriptionAggregateGroupBy {
  environmentId: String
  id: String
  createdAt: DateTime
  startDate: DateTime
  endDate: DateTime
  cancellationDate: DateTime
  trialEndDate: DateTime
  effectiveEndDate: DateTime
  billingCycleAnchor: DateTime
  billingId: String
  oldBillingId: String
  crmId: String
  crmLinkUrl: String
  status: SubscriptionStatus
  cancelReason: SubscriptionCancelReason
  refId: String
  subscriptionId: String
  customerId: String
  payingCustomerId: String
  resourceId: String
  currentBillingPeriodStart: DateTime
  currentBillingPeriodEnd: DateTime
  pricingType: PricingType
  paymentCollection: PaymentCollection
}

type CustomerSubscriptionCountAggregate {
  environmentId: Int
  id: Int
  createdAt: Int
  startDate: Int
  endDate: Int
  cancellationDate: Int
  trialEndDate: Int
  effectiveEndDate: Int
  billingCycleAnchor: Int
  billingId: Int
  oldBillingId: Int
  crmId: Int
  crmLinkUrl: Int
  status: Int
  cancelReason: Int
  refId: Int
  subscriptionId: Int
  customerId: Int
  payingCustomerId: Int
  resourceId: Int
  currentBillingPeriodStart: Int
  currentBillingPeriodEnd: Int
  pricingType: Int
  paymentCollection: Int
}

type CustomerSubscriptionMinAggregate {
  environmentId: String
  id: String
  createdAt: DateTime
  startDate: DateTime
  endDate: DateTime
  cancellationDate: DateTime
  trialEndDate: DateTime
  effectiveEndDate: DateTime
  billingCycleAnchor: DateTime
  billingId: String
  oldBillingId: String
  crmId: String
  crmLinkUrl: String
  status: SubscriptionStatus
  cancelReason: SubscriptionCancelReason
  refId: String
  subscriptionId: String
  customerId: String
  payingCustomerId: String
  resourceId: String
  currentBillingPeriodStart: DateTime
  currentBillingPeriodEnd: DateTime
  pricingType: PricingType
  paymentCollection: PaymentCollection
}

type CustomerSubscriptionMaxAggregate {
  environmentId: String
  id: String
  createdAt: DateTime
  startDate: DateTime
  endDate: DateTime
  cancellationDate: DateTime
  trialEndDate: DateTime
  effectiveEndDate: DateTime
  billingCycleAnchor: DateTime
  billingId: String
  oldBillingId: String
  crmId: String
  crmLinkUrl: String
  status: SubscriptionStatus
  cancelReason: SubscriptionCancelReason
  refId: String
  subscriptionId: String
  customerId: String
  payingCustomerId: String
  resourceId: String
  currentBillingPeriodStart: DateTime
  currentBillingPeriodEnd: DateTime
  pricingType: PricingType
  paymentCollection: PaymentCollection
}

type SubscriptionAddonEdge {
  """The node containing the SubscriptionAddon"""
  node: SubscriptionAddon!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type SubscriptionAddonAggregateGroupBy {
  id: String
  quantity: Float
  updatedAt: DateTime
  createdAt: DateTime
}

type SubscriptionAddonCountAggregate {
  id: Int
  quantity: Int
  updatedAt: Int
  createdAt: Int
}

type SubscriptionAddonSumAggregate {
  quantity: Float
}

type SubscriptionAddonAvgAggregate {
  quantity: Float
}

type SubscriptionAddonMinAggregate {
  id: String
  quantity: Float
  updatedAt: DateTime
  createdAt: DateTime
}

type SubscriptionAddonMaxAggregate {
  id: String
  quantity: Float
  updatedAt: DateTime
  createdAt: DateTime
}

type SubscriptionPriceEdge {
  """The node containing the SubscriptionPrice"""
  node: SubscriptionPrice!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type SubscriptionPriceAggregateGroupBy {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  usageLimit: Float
  hasSoftLimit: Boolean
  featureId: String
  billingModel: BillingModel
}

type SubscriptionPriceCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  usageLimit: Int
  hasSoftLimit: Int
  featureId: Int
  billingModel: Int
}

type SubscriptionPriceSumAggregate {
  usageLimit: Float
}

type SubscriptionPriceAvgAggregate {
  usageLimit: Float
}

type SubscriptionPriceMinAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  usageLimit: Float
  featureId: String
  billingModel: BillingModel
}

type SubscriptionPriceMaxAggregate {
  id: String
  createdAt: DateTime
  updatedAt: DateTime
  usageLimit: Float
  featureId: String
  billingModel: BillingModel
}

type MembersInviteResponse {
  successInvites: [String!]!
  skippedInvites: [String!]!
  failedInvites: [String!]!
}

type MemberEdge {
  """The node containing the Member"""
  node: Member!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type MemberConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [MemberEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type MemberAggregateGroupBy {
  id: String
  createdAt: DateTime
  email: String
}

type MemberCountAggregate {
  id: Int
  createdAt: Int
  email: Int
}

type MemberMinAggregate {
  id: String
  createdAt: DateTime
  email: String
}

type MemberMaxAggregate {
  id: String
  createdAt: DateTime
  email: String
}

type UnsupportedFeatureTypeError {
  code: String!
  featureType: String!
}

type SubscriptionNoBillingId {
  code: String!
  isValidationError: Boolean!
  refId: String!
}

type UsageMeasurement {
  id: String!
  value: Float!
  featureId: String!
  customerId: String!
  environmentId: String!
  createdAt: DateTime!
  environment: Environment!
  feature: Feature!
  customer: Customer!
}

type UsageMeasurementWithCurrentUsage {
  id: String!
  value: Float!
  currentUsage: Float

  """
  The start date of the usage period that the measurement resides in (for entitlement with reset period)
  """
  usagePeriodStart: DateTime

  """
  The end date of the usage period that the measurement resides in (for entitlement with reset period)
  """
  usagePeriodEnd: DateTime
  nextResetDate: DateTime @deprecated(reason: "renamed to usagePeriodEnd")
  timestamp: DateTime!
  featureId: String!
  environmentId: String!
  customerId: String!
  resourceId: String
  createdAt: DateTime!
}

"""Marker for a event affecting usage"""
type UsageMarker {
  """Type of marker"""
  type: UsageMarkerType!

  """Timestamp of the marker"""
  timestamp: DateTime!
}

"""Type of marker for a usage history point"""
enum UsageMarkerType {
  """Usage was reset due to reaching the end of a usage period"""
  PERIODIC_RESET

  """Usage was reset due to a subscription change"""
  SUBSCRIPTION_CHANGE_RESET
}

"""Point in the usage history"""
type UsageHistoryPoint {
  """Timestamp of the usage history point"""
  timestamp: DateTime!

  """Value of the usage history point"""
  value: Float!

  """
  Indicates whether there was usage reset in this point, see `markers` for details
  """
  isResetPoint: Boolean!
}

"""Tag for the usage history series"""
type UsageHistorySeriesTag {
  """Key of the tag"""
  key: String!

  """Value of the tag"""
  value: String!
}

"""Series of usage history"""
type UsageHistorySeries {
  """Tags for the usage history series"""
  tags: [UsageHistorySeriesTag!]!

  """Points in the usage history series"""
  points: [UsageHistoryPoint!]!
}

"""Usage history"""
type UsageHistoryV2 {
  """Series of usage history"""
  series: [UsageHistorySeries!]!

  """Markers for events that affecting feature usage"""
  markers: [UsageMarker!]!
}

type UsageMeasurementPoint {
  """Timestamp of the measurement point"""
  date: DateTime!

  """Value of the measurement point"""
  value: Float!

  """
  Indicates whether there was usage reset in this point, see `markers` for details
  """
  isResetPoint: Boolean!
}

type GroupInfo {
  key: String!
  value: String!
}

type GroupUsageHistory {
  groupInfo: [GroupInfo!]!
  usageMeasurements: [UsageMeasurementPoint!]!
}

type UsageHistory {
  startDate: DateTime!
  endDate: DateTime
  usageMeasurements: [UsageMeasurementPoint!]!
  groups: [GroupUsageHistory!]

  """Markers for events that affecting feature usage"""
  markers: [UsageMarker!]!
}

type UsageEvent {
  """The id of the event"""
  id: String!

  """The customer id reported"""
  customerId: String!

  """The customer object reported"""
  customer: Customer

  """The resource id reported"""
  resourceId: String

  """The event name reported"""
  eventName: String!

  """The timestamp reported"""
  timestamp: String!

  """The idempotency key reported"""
  idempotencyKey: String!

  """The dimensions reported"""
  dimensions: JSON
}

type UsageEventsPreview {
  """List of events"""
  events: [UsageEvent!]!
}

type CustomerAggregatedUsage {
  customerId: String!
  usage: Float!
}

type AggregatedEventsByCustomer {
  aggregatedUsage: [CustomerAggregatedUsage!]!
}

type EventsFields {
  fields: JSON!
}

type UsageMeasurementEdge {
  """The node containing the UsageMeasurement"""
  node: UsageMeasurement!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type UsageMeasurementConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [UsageMeasurementEdge!]!

  """Fetch total count of records"""
  totalCount: Int!
}

type UsageMeasurementAggregateGroupBy {
  id: String
  environmentId: String
  createdAt: DateTime
}

type UsageMeasurementCountAggregate {
  id: Int
  environmentId: Int
  createdAt: Int
}

type UsageMeasurementSumAggregate {
  id: Float
}

type UsageMeasurementAvgAggregate {
  id: Float
}

type UsageMeasurementMinAggregate {
  id: String
  environmentId: String
  createdAt: DateTime
}

type UsageMeasurementMaxAggregate {
  id: String
  environmentId: String
  createdAt: DateTime
}

type EventLog {
  """The ID of the event"""
  id: String!

  """The timestamp the event was created at"""
  createdAt: DateTime!

  """The account ID"""
  accountId: String!

  """The environment ID"""
  environmentId: String!

  """The type of the event"""
  eventLogType: EventLogType!

  """The event entity type"""
  entityType: EventEntityType

  """The entity id of this event"""
  entityId: String

  """The parent entity id of this events entity"""
  parentEntityId: String

  """The payload of the event"""
  payload: JSON!

  """Request information"""
  request: EventRequest

  """Actor information"""
  actor: EventActorInfo

  """List of webhooks endpoints this event was configured to be sent to"""
  webhooks: [EventWebhook!]
}

"""Event entity type"""
enum EventEntityType {
  """Customer entity"""
  CUSTOMER

  """Subscription entity"""
  SUBSCRIPTION

  """Plan entity"""
  PLAN

  """Add-on entity"""
  ADDON

  """Feature entity"""
  FEATURE

  """Entitlement entity"""
  ENTITLEMENT

  """Measurement entity"""
  MEASUREMENT

  """Promotional entitlement entity"""
  PROMOTIONAL_ENTITLEMENT

  """Package entity"""
  PACKAGE

  """Coupon entity"""
  COUPON

  """Import entity"""
  IMPORT

  """Product entity"""
  PRODUCT

  """Package group entity"""
  PACKAGE_GROUP
}

"""Event actor information"""
type EventActorInfo {
  """Actor type"""
  type: EventActor

  """Actor name"""
  name: String

  """Actor email"""
  email: String

  """Actor IP address"""
  ipAddress: String
}

"""Event actor type"""
enum EventActor {
  """Web application user"""
  USER

  """Client SDK"""
  APP_PUBLIC

  """Client SDK with hardened authentication"""
  APP_CUSTOMER

  """Backend SDK"""
  APP_SERVER

  """Stigg user service key"""
  SERVICE

  """Salesforce API key"""
  SALESFORCE

  """Stigg customer support"""
  SUPPORT

  """Stigg internal system"""
  SYSTEM

  """Stigg scheduler"""
  SCHEDULER

  """Stripe triggered event"""
  STRIPE

  """AWS triggered event"""
  AWS

  """Migration triggered event"""
  MIGRATION

  """Import triggered event"""
  IMPORT
}

"""An event webhook entity"""
type EventWebhook {
  """The ID of the webhook entity"""
  id: String!

  """The endpoint of the webhook"""
  endpoint: String!
}

"""Event request properties"""
type EventRequest {
  """The request trace ID"""
  traceId: String

  """The request body"""
  body: JSON

  """The request response"""
  response: JSON
}

type EventLogEdge {
  """The node containing the EventLog"""
  node: EventLog!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type EventLogConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [EventLogEdge!]!
}

type EventLogAggregateGroupBy {
  id: String
  createdAt: DateTime
  environmentId: String
  eventLogType: EventLogType
  entityId: String
  parentEntityId: String
}

type EventLogCountAggregate {
  id: Int
  createdAt: Int
  environmentId: Int
  eventLogType: Int
  entityId: Int
  parentEntityId: Int
}

type EventLogMinAggregate {
  id: String
  createdAt: DateTime
  environmentId: String
  eventLogType: EventLogType
  entityId: String
  parentEntityId: String
}

type EventLogMaxAggregate {
  id: String
  createdAt: DateTime
  environmentId: String
  eventLogType: EventLogType
  entityId: String
  parentEntityId: String
}

"""error codes"""
enum ErrorCode {
  RateLimitExceeded
  BadUserInput
  Unauthenticated
  CustomerNotFound
  TooManySubscriptionsPerCustomer
  CustomerResourceNotFound
  FeatureNotFound
  DuplicatedEntityNotAllowed

  """
  Duplicate integration for same non billing vendor identifier not allowed
  """
  DuplicateIntegrationNotAllowed
  EntityIsArchivedError
  IntegrityViolation
  MemberNotFound
  PlanNotFound

  """Free plan can't have compatible package groups error"""
  FreePlanCantHaveCompatiblePackageGroupError
  PackageGroupNotFound
  PromotionalEntitlementNotFoundError
  SubscriptionMustHaveSinglePlanError
  AddonNotFound

  """Multiple addons not found"""
  AddonsNotFound

  """Cannot delete an addon that is compatible with a plan"""
  AddonIsCompatibleWithPlan

  """Cannot delete an addon that is compatible with an addon group"""
  AddonIsCompatibleWithGroup

  """Duplicate addons provisioned error"""
  DuplicateAddonProvisionedError
  ScheduledMigrationAlreadyExistsError
  SubscriptionAlreadyOnLatestPlanError
  EnvironmentMissing
  EntityIdDifferentFromRefIdError
  UnsupportedFeatureType
  UnsupportedVendorIdentifier
  UnsupportedSubscriptionScheduleType
  InvalidEntitlementResetPeriod
  IncompatibleSubscriptionAddon
  UnPublishedPackage
  MeteringNotAvailableForFeatureType
  IdentityForbidden

  """The authenticated customer does not match the customer in the request"""
  AuthCustomerMismatch

  """
  The authenticated customer has read-only permissions and cannot perform this operation
  """
  AuthCustomerReadonly
  FetchAllCountriesPricesNotAllowed
  MemberInvitationError
  UnexpectedError
  PlansCircularDependencyError
  NoFeatureEntitlementInSubscription
  CheckoutIsNotSupported
  BillingIntegrationMissing
  BillingIntegrationAlreadyExistsError
  PriceNotFound
  InvalidMemberDelete
  PackageAlreadyPublished
  SubscriptionNotFound
  DraftPlanCantBeArchived

  """Draft addon cannot be archived"""
  DraftAddonCantBeArchived
  PlanWithChildCantBeDeleted
  PlanCannotBePublishWhenBasePlanIsDraft
  PlanCannotBePublishWhenCompatibleAddonIsDraft
  PlanIsUsedAsDefaultStartPlan
  PlanIsUsedAsDowngradePlan
  InvalidAddressError
  InvalidQuantity
  BillingPeriodMissingError
  DowngradeBillingPeriodNotSupportedError
  CustomerAlreadyUsesCoupon
  CustomerAlreadyHaveCustomerCoupon
  SubscriptionAlreadyCanceledOrExpired
  TrialMustBeCancelledImmediately
  SubscriptionDoesNotHaveBillingPeriod
  InvalidCancellationDate
  FailedToImportCustomer
  PackagePricingTypeNotSet
  InvalidSubscriptionStatus
  InvalidArgumentError
  EditAllowedOnDraftPackageOnlyError
  IntegrationNotFound
  ResyncAlreadyInProgress
  CouponNotFound
  ArchivedCouponCantBeApplied
  ImportAlreadyInProgress
  CustomerNoBillingId
  SubscriptionNoBillingId
  StripeCustomerIsDeleted
  InitStripePaymentMethodError
  PreparePaymentMethodFormError
  AddonHasToHavePriceError
  SelectedBillingModelDoesntMatchImportedItemError
  CannotDeleteProductError
  CannotDeleteCustomerError
  CannotRemovePaymentMethodFromCustomerError
  CannotDeleteFeatureError
  CannotArchiveFeatureError
  InvalidUpdatePriceUnitAmountError
  AccountNotFoundError
  ExperimentNotFoundError
  ExperimentAlreadyRunning
  ExperimentStatusError
  OperationNotAllowedDuringInProgressExperiment
  EntitlementsMustBelongToSamePackage
  MeterMustBeAssociatedToMeteredFeature
  CannotEditPackageInNonDraftMode

  """Cannot add override entitlement to a plan"""
  CannotAddOverrideEntitlementToPlan
  MissingEntityIdError
  NoProductsAvailable
  PromotionCodeNotFound
  PromotionCodeNotForCustomer
  PromotionCodeNotActive
  PromotionCodeMaxRedemptionsReached
  PromotionCodeMinimumAmountNotReached
  PromotionCodeCustomerNotFirstPurchase
  FailedToCreateCheckoutSessionError
  AddonWithDraftCannotBeDeletedError
  PaymentMethodNotFoundError
  StripeError
  CannotReportUsageForEntitlementWithMeterError
  RecalculateEntitlementsError
  ImportSubscriptionsBulkError
  InvalidMetadataError
  CannotUpsertToPackageThatHasDraft
  IntegrationValidationError
  AwsMarketplaceIntegrationValidationError
  AwsMarketplaceIntegrationError
  HubspotIntegrationError
  DuplicateProductValidationError
  AmountTooLarge
  CustomerHasNoEmailAddress
  MergeEnvironmentValidationError
  EntitlementLimitExceededError
  EntitlementUsageOutOfRangeError

  """This account has no access to the requested feature"""
  NoFeatureEntitlementError
  UsageMeasurementDiffOutOfRangeError
  ProductNotFoundError

  """Addon quantity exceeds limit error"""
  AddonQuantityExceedsLimitError

  """Addon dependency missing error"""
  AddonDependencyMissingError

  """Package group min items error"""
  PackageGroupMinItemsError
  MissingSubscriptionInvoiceError
  SubscriptionInvoiceStatusError

  """
  Can not update unit transformation since this feature has connected active subscriptions
  """
  CannotUpdateUnitTransformationError

  """
  Single subscription product cannot be a target of auto-cancellation rules
  """
  SingleSubscriptionCantBeAutoCancellationTargetError

  """
  Multi subscription product cannot be a source of auto-cancellation rules
  """
  MultiSubscriptionCantBeAutoCancellationSourceError

  """Changing paying customer is not supported"""
  ChangingPayingCustomerIsNotSupportedError
  RequiredSsoAuthenticationError
  AccessDeniedError
  InvalidDoggoSignatureError

  """Deleting the default integration is not allowed"""
  CannotDeleteDefaultIntegration
}

enum VendorIdentifier {
  AUTH0
  ZUORA
  STRIPE
  HUBSPOT
  AWS_MARKETPLACE
  SNOWFLAKE
  SALESFORCE
  BIG_QUERY
  OPEN_FGA
}

enum SourceType {
  JS_CLIENT_SDK
  NODE_SERVER_SDK
  PERSISTENT_CACHE_SERVICE
}

type Query {
  currentUser: User!
  getActiveSubscriptions(input: GetActiveSubscriptionsInput!): [CustomerSubscription!]!

  """Get subscription"""
  getSubscription(input: GetSubscriptionInput!): CustomerSubscription!
  fetchAccount: Account
  currentEnvironment: String!
  dumpEnvironmentForMergeComparison(input: DumpEnvironmentForForMergeComparisonInput!): DumpEnvironmentForMergeComparison!

  """Validate that one environment can be merged into another."""
  validateMergeEnvironment(input: ValidateMergeEnvironmentInput!): ValidateMergeEnvironment!

  """Dump environment product catalog."""
  dumpEnvironmentProductCatalog(input: DumpEnvironmentProductCatalogInput!): ProductCatalogDump!
  products(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: ProductFilter = {}

    """Specify to sort results."""
    sorting: [ProductSort!] = [{field: createdAt, direction: DESC}]
  ): ProductConnection!
  getPaywall(input: GetPaywallInput!): [Plan!]! @deprecated(reason: "Deprecated query, use paywall query instead")
  paywall(input: GetPaywallInput!): Paywall!
  mockPaywall(input: GetPaywallInput!): MockPaywall!
  getPlanByRefId(input: GetPackageByRefIdInput!): Plan
  getAddonByRefId(input: GetPackageByRefIdInput!): Addon

  """Get the latest associated entities of an addon"""
  addonAssociatedEntities(input: AddonAssociatedEntitiesInput!): AddonAssociatedEntities!
  sdkConfiguration: SdkConfiguration
  widgetConfiguration(input: GetWidgetConfigurationInput!): WidgetConfiguration!
  doesFeatureExist(input: DoesFeatureExist!): Boolean!
  featureAssociatedLatestPackages(input: FeatureAssociatedLatestPackages!): [PackageDTO!]!
  features(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: FeatureFilter = {}

    """Specify to sort results."""
    sorting: [FeatureSort!] = [{field: createdAt, direction: DESC}]
  ): FeatureConnection!
  entitlement(query: FetchEntitlementQuery!): Entitlement!
  cachedEntitlements(query: FetchEntitlementsQuery!): [Entitlement!]!
  entitlements(query: FetchEntitlementsQuery!): [EntitlementWithSummary!]!
  subscriptionMigrationTasks(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: SubscriptionMigrationTaskFilter = {}

    """Specify to sort results."""
    sorting: [SubscriptionMigrationTaskSort!] = [{field: createdAt, direction: DESC}]
  ): SubscriptionMigrationTaskConnection!
  importIntegrationTasks(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: ImportIntegrationTaskFilter = {}

    """Specify to sort results."""
    sorting: [ImportIntegrationTaskSort!] = [{field: createdAt, direction: DESC}]
  ): ImportIntegrationTaskConnection!
  packageEntitlements(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: PackageEntitlementFilter = {}

    """Specify to sort results."""
    sorting: [PackageEntitlementSort!] = [{field: createdAt, direction: DESC}]
  ): PackageEntitlementConnection!
  promotionalEntitlements(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: PromotionalEntitlementFilter = {}

    """Specify to sort results."""
    sorting: [PromotionalEntitlementSort!] = [{field: createdAt, direction: DESC}]
  ): PromotionalEntitlementConnection!
  subscriptionEntitlements(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: SubscriptionEntitlementFilter = {}

    """Specify to sort results."""
    sorting: [SubscriptionEntitlementSort!] = [{field: createdAt, direction: DESC}]
  ): SubscriptionEntitlementConnection!
  getExperimentStats(query: ExperimentStatsQuery!): ExperimentStats!
  stripeProducts(input: StripeProductSearchInput!): StripeProductSearchResult!
  stripeCustomers(input: StripeCustomerSearchInput!): StripeCustomerSearchResult!
  stripeSubscriptions(input: StripeSubscriptionSearchInput!): StripeSubscriptionSearchResult!
  getAwsExternalId: GetAwsExternalIdResult!
  listAwsProducts(input: ListAwsProductsInput!): ListAwsProductsResult!
  listAwsProductDimensions(input: ListAwsProductDimensionsInput!): ListAwsProductDimensionsDTO!
  coupon(
    """The id of the record to find."""
    id: String!
  ): Coupon
  coupons(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: CouponFilter = {}

    """Specify to sort results."""
    sorting: [CouponSort!] = [{field: createdAt, direction: DESC}]
  ): CouponConnection!
  getPackageGroup(input: GetPackageGroup!): PackageGroup!
  packageGroup(
    """The id of the record to find."""
    id: ID!
  ): PackageGroup
  packageGroups(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: PackageGroupFilter = {}

    """Specify to sort results."""
    sorting: [PackageGroupSort!] = [{field: createdAt, direction: DESC}]
  ): PackageGroupConnection!
  environments(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: EnvironmentFilter = {}

    """Specify to sort results."""
    sorting: [EnvironmentSort!] = [{field: createdAt, direction: DESC}]
  ): EnvironmentConnection!
  getAuth0Applications(input: GetAuth0ApplicationsInput!): [Auth0ApplicationDTO!]!
  integrations(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: IntegrationFilter = {}

    """Specify to sort results."""
    sorting: [IntegrationSort!] = [{field: createdAt, direction: DESC}]
  ): IntegrationConnection!
  experiment(
    """The id of the record to find."""
    id: String!
  ): Experiment
  experiments(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: ExperimentFilter = {}

    """Specify to sort results."""
    sorting: [ExperimentSort!] = [{field: createdAt, direction: DESC}]
  ): ExperimentConnection!
  plans(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: PlanFilter = {}

    """Specify to sort results."""
    sorting: [PlanSort!] = [{field: createdAt, direction: DESC}]
  ): PlanConnection!
  addons(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: AddonFilter = {}

    """Specify to sort results."""
    sorting: [AddonSort!] = [{field: createdAt, direction: DESC}]
  ): AddonConnection!
  checkoutState(input: CheckoutStateInput!): CheckoutState!
  customerPortal(input: CustomerPortalInput!): CustomerPortal!
  getCustomerByRefId(input: GetCustomerByRefIdInput!): Customer
  customers(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: CustomerFilter = {}

    """Specify to sort results."""
    sorting: [CustomerSort!] = [{field: createdAt, direction: DESC}]
  ): CustomerConnection!
  customerResources(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: CustomerResourceFilter = {}

    """Specify to sort results."""
    sorting: [CustomerResourceSort!] = [{field: createdAt, direction: DESC}]
  ): CustomerResourceConnection!
  customerSubscriptions(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: CustomerSubscriptionFilter = {}

    """Specify to sort results."""
    sorting: [CustomerSubscriptionSort!] = [{field: createdAt, direction: DESC}]
  ): CustomerSubscriptionConnection!
  members(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: MemberFilter = {}

    """Specify to sort results."""
    sorting: [MemberSort!] = [{field: createdAt, direction: DESC}]
  ): MemberConnection!

  """Get customer's usage history for a feature"""
  usageHistoryV2(input: UsageHistoryV2Input!): UsageHistoryV2!
  usageHistory(usageHistoryInput: UsageHistoryInput!): UsageHistory! @deprecated(reason: "usage usageHistoryV2 instead")
  usageEvents(input: UsageEventsInput!): UsageEventsPreview!
  aggregatedEventsByCustomer(input: AggregatedEventsByCustomerInput!): AggregatedEventsByCustomer!
  eventsFields(input: EventsFieldsInput!): EventsFields!
  usageMeasurements(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: UsageMeasurementFilter = {}

    """Specify to sort results."""
    sorting: [UsageMeasurementSort!] = [{field: createdAt, direction: DESC}]
  ): UsageMeasurementConnection!
  testHookData(eventLogType: EventLogType!): TestHook!
  sendTestHook(testHookInput: TestHookInput!): TestHookResult!
  hook(
    """The id of the record to find."""
    id: String!
  ): Hook
  hooks(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: HookFilter = {}

    """Specify to sort results."""
    sorting: [HookSort!] = [{field: createdAt, direction: DESC}]
  ): HookConnection!
  eventLogs(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: EventLogFilter!

    """Specify to sort results."""
    sorting: [EventLogSort!] = [{field: createdAt, direction: DESC}]
  ): EventLogConnection!
}

input GetActiveSubscriptionsInput {
  customerId: String!
  environmentId: String
  resourceId: String
  resourceIds: [String!]
}

"""Get subscription input"""
input GetSubscriptionInput {
  """The subscription ID to retrieve"""
  subscriptionId: String!

  """The environment ID the subscription belongs to"""
  environmentId: String
}

"""Input type for dumpEnvironmentForMergeComparison query."""
input DumpEnvironmentForForMergeComparisonInput {
  """The slug of the environment to copy from."""
  sourceEnvironmentSlug: String!

  """The slug of the environment to copy to."""
  destinationEnvironmentSlug: String!

  """Merge configuration."""
  mergeConfiguration: EnvironmentMergeConfigurationInput
}

"""Merge configuration"""
input EnvironmentMergeConfigurationInput {
  """Whether to include coupons during the merge."""
  includeCoupons: Boolean
}

"""Input type for validateMergeEnvironment query."""
input ValidateMergeEnvironmentInput {
  """The slug of the environment to copy from."""
  sourceEnvironmentSlug: String!

  """The slug of the environment to copy to."""
  destinationEnvironmentSlug: String!

  """Merge configuration"""
  mergeConfiguration: EnvironmentMergeConfigurationInput
}

"""Input type for dumpEnvironmentProductCatalog mutation."""
input DumpEnvironmentProductCatalogInput {
  """The slug of the environment to dump."""
  environmentSlug: String!
}

input CursorPaging {
  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

input ProductFilter {
  and: [ProductFilter!]
  or: [ProductFilter!]
  id: StringFieldComparison
  displayName: StringFieldComparison
  refId: StringFieldComparison
  description: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  environmentId: StringFieldComparison
  isDefaultProduct: BooleanFieldComparison
  multipleSubscriptions: BooleanFieldComparison
  awsMarketplaceProductId: StringFieldComparison
  awsMarketplaceProductCode: StringFieldComparison
}

input ProductSort {
  field: ProductSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProductSortFields {
  id
  displayName
  refId
  description
  createdAt
  updatedAt
  environmentId
  isDefaultProduct
  multipleSubscriptions
  awsMarketplaceProductId
  awsMarketplaceProductCode
}

input GetPaywallInput {
  environmentId: String
  productId: String
  customerId: String
  resourceId: String
  billingCountryCode: String
  fetchAllCountriesPrices: Boolean = false
  includeHiddenPlans: Boolean = false
  context: WidgetType
}

input GetPackageByRefIdInput {
  refId: String!
  versionNumber: Float
  environmentId: String!
}

"""Query associated entities input"""
input AddonAssociatedEntitiesInput {
  """Addon id"""
  refId: String!

  """Environment id"""
  environmentId: String!
}

input GetWidgetConfigurationInput {
  environmentId: String
}

input DoesFeatureExist {
  environmentId: String!
  refId: String!
}

input FeatureAssociatedLatestPackages {
  environmentId: String!
  featureId: String!
}

input FeatureFilter {
  and: [FeatureFilter!]
  or: [FeatureFilter!]
  id: StringFieldComparison
  displayName: StringFieldComparison
  refId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  description: StringFieldComparison
  featureType: FeatureTypeFilterComparison
  meterType: MeterTypeFilterComparison
  featureStatus: FeatureStatusFilterComparison
  environmentId: StringFieldComparison
}

input FeatureSort {
  field: FeatureSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FeatureSortFields {
  id
  displayName
  refId
  createdAt
  updatedAt
  description
  featureType
  meterType
  featureStatus
  environmentId
}

input FetchEntitlementQuery {
  customerId: String!
  resourceId: String
  featureId: String!
  options: EntitlementOptions
  environmentId: String
}

input EntitlementOptions {
  shouldTrack: Boolean = false
  requestedUsage: Float
}

input FetchEntitlementsQuery {
  customerId: String!
  resourceId: String
  environmentId: String
}

input SubscriptionMigrationTaskFilter {
  and: [SubscriptionMigrationTaskFilter!]
  or: [SubscriptionMigrationTaskFilter!]
  id: StringFieldComparison
  environmentId: StringFieldComparison
  createdAt: DateFieldComparison
  taskType: TaskTypeFilterComparison
  status: TaskStatusFilterComparison
}

input TaskTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: TaskType
  neq: TaskType
  gt: TaskType
  gte: TaskType
  lt: TaskType
  lte: TaskType
  like: TaskType
  notLike: TaskType
  iLike: TaskType
  notILike: TaskType
  in: [TaskType!]
  notIn: [TaskType!]
}

input TaskStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: TaskStatus
  neq: TaskStatus
  gt: TaskStatus
  gte: TaskStatus
  lt: TaskStatus
  lte: TaskStatus
  like: TaskStatus
  notLike: TaskStatus
  iLike: TaskStatus
  notILike: TaskStatus
  in: [TaskStatus!]
  notIn: [TaskStatus!]
}

input SubscriptionMigrationTaskSort {
  field: SubscriptionMigrationTaskSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SubscriptionMigrationTaskSortFields {
  id
  environmentId
  createdAt
  taskType
  status
}

input ImportIntegrationTaskFilter {
  and: [ImportIntegrationTaskFilter!]
  or: [ImportIntegrationTaskFilter!]
  id: StringFieldComparison
  environmentId: StringFieldComparison
  createdAt: DateFieldComparison
  taskType: TaskTypeFilterComparison
  status: TaskStatusFilterComparison
}

input ImportIntegrationTaskSort {
  field: ImportIntegrationTaskSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ImportIntegrationTaskSortFields {
  id
  environmentId
  createdAt
  taskType
  status
}

input PackageEntitlementFilter {
  and: [PackageEntitlementFilter!]
  or: [PackageEntitlementFilter!]
  id: StringFieldComparison
  packageId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  environmentId: StringFieldComparison
  package: PackageEntitlementFilterPackageDTOFilter
  feature: PackageEntitlementFilterFeatureFilter
}

input PackageEntitlementFilterPackageDTOFilter {
  and: [PackageEntitlementFilterPackageDTOFilter!]
  or: [PackageEntitlementFilterPackageDTOFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  refId: StringFieldComparison
  billingId: StringFieldComparison
  displayName: StringFieldComparison
  status: PackageStatusFilterComparison
  pricingType: PricingTypeFilterComparison
  description: StringFieldComparison
  environmentId: StringFieldComparison
  productId: StringFieldComparison
  isLatest: BooleanFieldComparison
  versionNumber: IntFieldComparison
}

input PackageEntitlementFilterFeatureFilter {
  and: [PackageEntitlementFilterFeatureFilter!]
  or: [PackageEntitlementFilterFeatureFilter!]
  id: StringFieldComparison
  displayName: StringFieldComparison
  refId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  description: StringFieldComparison
  featureType: FeatureTypeFilterComparison
  meterType: MeterTypeFilterComparison
  featureStatus: FeatureStatusFilterComparison
  environmentId: StringFieldComparison
}

input PackageEntitlementSort {
  field: PackageEntitlementSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PackageEntitlementSortFields {
  id
  packageId
  createdAt
  updatedAt
  environmentId
}

input ExperimentStatsQuery {
  experimentRefId: String!
  environmentId: String
}

input StripeProductSearchInput {
  environmentId: String!
  nextPage: String
  productName: String
}

input StripeCustomerSearchInput {
  environmentId: String!
  nextPage: String
  customerName: String
}

input StripeSubscriptionSearchInput {
  environmentId: String!
  nextPage: String
}

input ListAwsProductsInput {
  environmentId: String
}

input ListAwsProductDimensionsInput {
  environmentId: String
  productId: String!
}

input CouponFilter {
  and: [CouponFilter!]
  or: [CouponFilter!]
  id: StringFieldComparison
  name: StringFieldComparison
  refId: StringFieldComparison
  description: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  environmentId: StringFieldComparison
  type: CouponTypeFilterComparison
  status: CouponStatusFilterComparison
  source: CouponSourceFilterComparison
  billingId: StringFieldComparison
  customers: CouponFilterCustomerFilter
}

input CouponTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: CouponType
  neq: CouponType
  gt: CouponType
  gte: CouponType
  lt: CouponType
  lte: CouponType
  like: CouponType
  notLike: CouponType
  iLike: CouponType
  notILike: CouponType
  in: [CouponType!]
  notIn: [CouponType!]
}

input CouponStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: CouponStatus
  neq: CouponStatus
  gt: CouponStatus
  gte: CouponStatus
  lt: CouponStatus
  lte: CouponStatus
  like: CouponStatus
  notLike: CouponStatus
  iLike: CouponStatus
  notILike: CouponStatus
  in: [CouponStatus!]
  notIn: [CouponStatus!]
}

input CouponSourceFilterComparison {
  eq: CouponSource
  in: [CouponSource!]
}

input CouponFilterCustomerFilter {
  and: [CouponFilterCustomerFilter!]
  or: [CouponFilterCustomerFilter!]
  id: StringFieldComparison
  name: StringFieldComparison
  email: StringFieldComparison
  refId: StringFieldComparison
  customerId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  environmentId: StringFieldComparison
  billingId: StringFieldComparison
  crmId: StringFieldComparison
  crmHubspotCompanyId: StringFieldComparison
  crmHubspotCompanyUrl: StringFieldComparison
  searchQuery: CustomerSearchQueryFilterComparison
}

input CouponSort {
  field: CouponSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CouponSortFields {
  id
  name
  refId
  description
  createdAt
  updatedAt
  environmentId
  type
  status
  source
  billingId
}

"""The input type for getting an package group"""
input GetPackageGroup {
  """The id of the package group"""
  packageGroupId: String!

  """The version number of the package group"""
  versionNumber: Float

  """The environment id to get the package group in"""
  environmentId: String!
}

input PackageGroupFilter {
  and: [PackageGroupFilter!]
  or: [PackageGroupFilter!]
  displayName: StringFieldComparison
  packageGroupId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  environmentId: StringFieldComparison
  isLatest: BooleanFieldComparison
  versionNumber: IntFieldComparison
  status: PackageGroupStatusFilterComparison
  productId: StringFieldComparison
  product: PackageGroupFilterProductFilter
}

input PackageGroupStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PackageGroupStatus
  neq: PackageGroupStatus
  gt: PackageGroupStatus
  gte: PackageGroupStatus
  lt: PackageGroupStatus
  lte: PackageGroupStatus
  like: PackageGroupStatus
  notLike: PackageGroupStatus
  iLike: PackageGroupStatus
  notILike: PackageGroupStatus
  in: [PackageGroupStatus!]
  notIn: [PackageGroupStatus!]
}

input PackageGroupFilterProductFilter {
  and: [PackageGroupFilterProductFilter!]
  or: [PackageGroupFilterProductFilter!]
  id: StringFieldComparison
  displayName: StringFieldComparison
  refId: StringFieldComparison
  description: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  environmentId: StringFieldComparison
  isDefaultProduct: BooleanFieldComparison
  multipleSubscriptions: BooleanFieldComparison
  awsMarketplaceProductId: StringFieldComparison
  awsMarketplaceProductCode: StringFieldComparison
}

input PackageGroupSort {
  field: PackageGroupSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PackageGroupSortFields {
  displayName
  packageGroupId
  createdAt
  updatedAt
  environmentId
  isLatest
  versionNumber
  status
  productId
}

input EnvironmentFilter {
  and: [EnvironmentFilter!]
  or: [EnvironmentFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  displayName: StringFieldComparison
  slug: StringFieldComparison
  permanentDeletionDate: DateFieldComparison
}

input EnvironmentSort {
  field: EnvironmentSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum EnvironmentSortFields {
  id
  createdAt
  displayName
  slug
  permanentDeletionDate
}

input GetAuth0ApplicationsInput {
  environmentId: String
  clientDomain: String!
  clientId: String!
  clientSecret: String!
}

input IntegrationFilter {
  and: [IntegrationFilter!]
  or: [IntegrationFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  environmentId: StringFieldComparison
  vendorIdentifier: VendorIdentifierFilterComparison
  vendorType: IntegrationVendorTypeFilterComparison
}

input VendorIdentifierFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: VendorIdentifier
  neq: VendorIdentifier
  gt: VendorIdentifier
  gte: VendorIdentifier
  lt: VendorIdentifier
  lte: VendorIdentifier
  like: VendorIdentifier
  notLike: VendorIdentifier
  iLike: VendorIdentifier
  notILike: VendorIdentifier
  in: [VendorIdentifier!]
  notIn: [VendorIdentifier!]
}

input IntegrationVendorTypeFilterComparison {
  eq: VendorType
  neq: VendorType
  in: [VendorType!]
  notIn: [VendorType!]
}

input IntegrationSort {
  field: IntegrationSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum IntegrationSortFields {
  id
  createdAt
  environmentId
  vendorIdentifier
  vendorType
}

input ExperimentFilter {
  and: [ExperimentFilter!]
  or: [ExperimentFilter!]
  id: StringFieldComparison
  name: StringFieldComparison
  refId: StringFieldComparison
  createdAt: DateFieldComparison
  environmentId: StringFieldComparison
  productId: StringFieldComparison
  status: ExperimentStatusFilterComparison
  customers: ExperimentFilterCustomerFilter
}

input ExperimentStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ExperimentStatus
  neq: ExperimentStatus
  gt: ExperimentStatus
  gte: ExperimentStatus
  lt: ExperimentStatus
  lte: ExperimentStatus
  like: ExperimentStatus
  notLike: ExperimentStatus
  iLike: ExperimentStatus
  notILike: ExperimentStatus
  in: [ExperimentStatus!]
  notIn: [ExperimentStatus!]
}

input ExperimentFilterCustomerFilter {
  and: [ExperimentFilterCustomerFilter!]
  or: [ExperimentFilterCustomerFilter!]
  id: StringFieldComparison
  name: StringFieldComparison
  email: StringFieldComparison
  refId: StringFieldComparison
  customerId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  environmentId: StringFieldComparison
  billingId: StringFieldComparison
  crmId: StringFieldComparison
  crmHubspotCompanyId: StringFieldComparison
  crmHubspotCompanyUrl: StringFieldComparison
  searchQuery: CustomerSearchQueryFilterComparison
}

input ExperimentSort {
  field: ExperimentSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ExperimentSortFields {
  id
  name
  refId
  createdAt
  environmentId
  productId
  status
}

input PlanFilter {
  and: [PlanFilter!]
  or: [PlanFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  refId: StringFieldComparison
  billingId: StringFieldComparison
  displayName: StringFieldComparison
  status: PackageStatusFilterComparison
  pricingType: PricingTypeFilterComparison
  description: StringFieldComparison
  environmentId: StringFieldComparison
  productId: StringFieldComparison
  isLatest: BooleanFieldComparison
  versionNumber: IntFieldComparison
  product: PlanFilterProductFilter
  compatibleAddons: PlanFilterAddonFilter
}

input PlanFilterProductFilter {
  and: [PlanFilterProductFilter!]
  or: [PlanFilterProductFilter!]
  id: StringFieldComparison
  displayName: StringFieldComparison
  refId: StringFieldComparison
  description: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  environmentId: StringFieldComparison
  isDefaultProduct: BooleanFieldComparison
  multipleSubscriptions: BooleanFieldComparison
  awsMarketplaceProductId: StringFieldComparison
  awsMarketplaceProductCode: StringFieldComparison
}

input PlanFilterAddonFilter {
  and: [PlanFilterAddonFilter!]
  or: [PlanFilterAddonFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  refId: StringFieldComparison
  billingId: StringFieldComparison
  displayName: StringFieldComparison
  status: PackageStatusFilterComparison
  pricingType: PricingTypeFilterComparison
  description: StringFieldComparison
  environmentId: StringFieldComparison
  productId: StringFieldComparison
  isLatest: BooleanFieldComparison
  versionNumber: IntFieldComparison
}

input PlanSort {
  field: PlanSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PlanSortFields {
  id
  createdAt
  updatedAt
  refId
  billingId
  displayName
  status
  pricingType
  description
  environmentId
  productId
  isLatest
  versionNumber
}

input CheckoutStateInput {
  customerId: String!
  planId: String!
  productId: String
  resourceId: String
  billingCountryCode: String
}

input CustomerPortalInput {
  productId: String
  customerId: String!
  resourceId: String
}

input GetCustomerByRefIdInput {
  customerId: String!
  environmentId: String
}

input CustomerResourceFilter {
  and: [CustomerResourceFilter!]
  or: [CustomerResourceFilter!]
  environmentId: StringFieldComparison
  resourceId: StringFieldComparison
  createdAt: DateFieldComparison
  customer: CustomerResourceFilterCustomerFilter
  subscriptions: CustomerResourceFilterCustomerSubscriptionFilter
}

input CustomerResourceFilterCustomerFilter {
  and: [CustomerResourceFilterCustomerFilter!]
  or: [CustomerResourceFilterCustomerFilter!]
  id: StringFieldComparison
  name: StringFieldComparison
  email: StringFieldComparison
  refId: StringFieldComparison
  customerId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  environmentId: StringFieldComparison
  billingId: StringFieldComparison
  crmId: StringFieldComparison
  crmHubspotCompanyId: StringFieldComparison
  crmHubspotCompanyUrl: StringFieldComparison
  searchQuery: CustomerSearchQueryFilterComparison
}

input CustomerResourceFilterCustomerSubscriptionFilter {
  and: [CustomerResourceFilterCustomerSubscriptionFilter!]
  or: [CustomerResourceFilterCustomerSubscriptionFilter!]
  environmentId: StringFieldComparison
  id: StringFieldComparison
  createdAt: DateFieldComparison
  startDate: DateFieldComparison
  endDate: DateFieldComparison
  cancellationDate: DateFieldComparison
  trialEndDate: DateFieldComparison
  effectiveEndDate: DateFieldComparison
  billingCycleAnchor: DateFieldComparison
  billingId: StringFieldComparison
  oldBillingId: StringFieldComparison
  crmId: StringFieldComparison
  crmLinkUrl: StringFieldComparison
  status: SubscriptionStatusFilterComparison
  cancelReason: SubscriptionCancelReasonFilterComparison
  refId: StringFieldComparison
  subscriptionId: StringFieldComparison
  customerId: StringFieldComparison
  payingCustomerId: StringFieldComparison
  resourceId: StringFieldComparison
  currentBillingPeriodStart: DateFieldComparison
  currentBillingPeriodEnd: DateFieldComparison
  pricingType: PricingTypeFilterComparison
  paymentCollection: PaymentCollectionFilterComparison
}

input CustomerResourceSort {
  field: CustomerResourceSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CustomerResourceSortFields {
  environmentId
  resourceId
  createdAt
}

input MemberFilter {
  and: [MemberFilter!]
  or: [MemberFilter!]
  id: StringFieldComparison
  createdAt: DateFieldComparison
  email: StringFieldComparison
  user: MemberFilterUserFilter
}

input MemberFilterUserFilter {
  and: [MemberFilterUserFilter!]
  or: [MemberFilterUserFilter!]
  id: StringFieldComparison
  email: StringFieldComparison
  name: StringFieldComparison
}

input MemberSort {
  field: MemberSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum MemberSortFields {
  id
  createdAt
  email
}

"""Input for fetching usage history"""
input UsageHistoryV2Input {
  """Customer ID"""
  customerId: String!

  """Resource ID"""
  resourceId: String

  """Feature ID"""
  featureId: String!

  """Start date of the usage history"""
  startDate: DateTime!

  """End date of the usage history"""
  endDate: DateTime

  """Group usage per keys"""
  groupBy: [String!]
  environmentId: String
}

input UsageHistoryInput {
  startDate: DateTime!
  endDate: DateTime
  featureRefId: String!
  customerRefId: String!
  resourceRefId: String
  resetPeriod: EntitlementResetPeriod
  yearlyResetPeriodConfiguration: YearlyResetPeriodConfigInput
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
  environmentId: String
  groupBy: [String!]
}

input YearlyResetPeriodConfigInput {
  accordingTo: YearlyAccordingTo!
}

input MonthlyResetPeriodConfigInput {
  accordingTo: MonthlyAccordingTo!
}

input WeeklyResetPeriodConfigInput {
  accordingTo: WeeklyAccordingTo!
}

input UsageEventsInput {
  """List of event filters"""
  filters: [MeterFilterDefinitionInput!]

  """Environment id filter"""
  environmentId: String!

  """Customer id filter"""
  customerId: String
}

input MeterFilterDefinitionInput {
  conditions: [MeterConditionInput!]!
}

input MeterConditionInput {
  operation: ConditionOperation!
  field: String!
  value: String
}

input AggregatedEventsByCustomerInput {
  filters: [MeterFilterDefinitionInput!]!
  aggregation: MeterAggregation!
  customerId: String
  environmentId: String!
}

input MeterAggregation {
  function: AggregationFunction!
  field: String
}

input EventsFieldsInput {
  filters: [MeterFilterDefinitionInput!]
  environmentId: String!
  meterId: String
  featureId: String
  customerId: String
  resourceId: String

  """Omit fields that have more than this number of unique values."""
  uniqueValuesLimit: Float
}

input UsageMeasurementFilter {
  and: [UsageMeasurementFilter!]
  or: [UsageMeasurementFilter!]
  id: StringFieldComparison
  environmentId: StringFieldComparison
  createdAt: DateFieldComparison
  customer: UsageMeasurementFilterCustomerFilter
  feature: UsageMeasurementFilterFeatureFilter
}

input UsageMeasurementFilterCustomerFilter {
  and: [UsageMeasurementFilterCustomerFilter!]
  or: [UsageMeasurementFilterCustomerFilter!]
  id: StringFieldComparison
  name: StringFieldComparison
  email: StringFieldComparison
  refId: StringFieldComparison
  customerId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  environmentId: StringFieldComparison
  billingId: StringFieldComparison
  crmId: StringFieldComparison
  crmHubspotCompanyId: StringFieldComparison
  crmHubspotCompanyUrl: StringFieldComparison
  searchQuery: CustomerSearchQueryFilterComparison
}

input UsageMeasurementFilterFeatureFilter {
  and: [UsageMeasurementFilterFeatureFilter!]
  or: [UsageMeasurementFilterFeatureFilter!]
  id: StringFieldComparison
  displayName: StringFieldComparison
  refId: StringFieldComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  description: StringFieldComparison
  featureType: FeatureTypeFilterComparison
  meterType: MeterTypeFilterComparison
  featureStatus: FeatureStatusFilterComparison
  environmentId: StringFieldComparison
}

input UsageMeasurementSort {
  field: UsageMeasurementSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum UsageMeasurementSortFields {
  id
  environmentId
  createdAt
}

input TestHookInput {
  environmentId: String!
  endpointUrl: String!
  hookEventType: EventLogType!
}

input HookFilter {
  and: [HookFilter!]
  or: [HookFilter!]
  id: StringFieldComparison
  endpoint: StringFieldComparison
  status: HookStatusFilterComparison
  createdAt: DateFieldComparison
  environmentId: StringFieldComparison
}

input HookStatusFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: HookStatus
  neq: HookStatus
  gt: HookStatus
  gte: HookStatus
  lt: HookStatus
  lte: HookStatus
  like: HookStatus
  notLike: HookStatus
  iLike: HookStatus
  notILike: HookStatus
  in: [HookStatus!]
  notIn: [HookStatus!]
}

input HookSort {
  field: HookSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum HookSortFields {
  id
  endpoint
  status
  createdAt
  environmentId
}

input EventLogFilter {
  and: [EventLogFilter!]
  or: [EventLogFilter!]
  id: EventLogIdFilterComparison
  createdAt: EventLogCreatedAtFilterComparison
  environmentId: EventLogEnvironmentIdFilterComparison!
  eventLogType: EventLogEventLogTypeFilterComparison
  entityId: EventLogEntityIdFilterComparison
  parentEntityId: EventLogParentEntityIdFilterComparison
}

input EventLogIdFilterComparison {
  eq: String
}

input EventLogCreatedAtFilterComparison {
  gte: DateTime
  lte: DateTime
}

input EventLogEnvironmentIdFilterComparison {
  eq: String
}

input EventLogEventLogTypeFilterComparison {
  eq: EventLogType
  neq: EventLogType
  in: [EventLogType!]
  notIn: [EventLogType!]
}

input EventLogEntityIdFilterComparison {
  eq: String
  in: [String!]
}

input EventLogParentEntityIdFilterComparison {
  eq: String
  in: [String!]
}

input EventLogSort {
  field: EventLogSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum EventLogSortFields {
  id
  createdAt
  environmentId
  eventLogType
  entityId
  parentEntityId
}

type Mutation {
  resendEmailVerification: String!
  updateUser(input: UpdateUserInput!): User!
  cancelSubscription(input: SubscriptionCancellationInput!): CustomerSubscription!
  createSubscription(subscription: SubscriptionInput!): CustomerSubscription!
  provisionSubscription(input: ProvisionSubscription!): ProvisionSubscriptionResult!
  provisionSubscriptionV2(input: ProvisionSubscriptionInput!): ProvisionSubscriptionResult!
  importSubscriptionsBulk(input: ImportSubscriptionsBulkInput!): String
  migrateSubscriptionToLatest(input: SubscriptionMigrationInput!): CustomerSubscription!
  transferSubscription(input: TransferSubscriptionInput!): CustomerSubscription! @deprecated(reason: "Deprecated mutation, use 'transferSubscriptionToResource' instead")

  """
  Delegates a subscription to a different customer (the paying customer of the subscription will not change)
  """
  delegateSubscriptionToCustomer(input: DelegateSubscriptionToCustomerInput!): CustomerSubscription!

  """Transfers a subscription to a different resource"""
  transferSubscriptionToResource(input: TransferSubscriptionToResourceInput!): CustomerSubscription!

  """
  Triggers the subscription billing month ends soon webhook for the given subscription
  """
  triggerSubscriptionBillingMonthEndsSoonWebhook(input: TriggerSubscriptionBillingMonthEndsSoonWebhookInput!): String!

  """Immediately charges usage in the given subscription"""
  chargeSubscriptionUsage(input: ChargeSubscriptionUsageInput!): ChargeSubscriptionUsage!

  """Triggers the subscription usage sync for the given subscription"""
  triggerSubscriptionUsageSync(input: TriggerSubscriptionUsageSyncInput!): Boolean!

  """Triggers mark invoice as paid for the given subscription"""
  markInvoiceAsPaid(input: MarkInvoiceAsPaidInput!): String
  updateOneSubscription(input: UpdateSubscriptionInput!): CustomerSubscription!
  estimateSubscription(input: EstimateSubscriptionInput!): SubscriptionPreview!
  estimateSubscriptionUpdate(input: EstimateSubscriptionUpdateInput!): SubscriptionPreview!
  previewNextInvoice(input: PreviewNextInvoiceInput!): SubscriptionInvoicePreview!
  subscriptionMaximumSpend(input: PreviewNextInvoiceInput!): SubscriptionMaximumSpend
  cancelSchedule(input: SubscriptionUpdateScheduleCancellationInput!): String!
  updateAccount(input: UpdateAccountInput!): Account!
  createAccount(accountName: String!): Member!
  createOneEnvironment(input: CreateOneEnvironmentInput!): Environment!
  archiveEnvironment(input: ArchiveEnvironmentInput!): Environment!
  unarchiveEnvironment(input: UnarchiveEnvironmentInput!): Environment!
  provisionSandbox(input: ProvisionSandboxInput!): Environment!

  """
  Merge data from an existing environment to another environment or to a new environment.
  """
  mergeEnvironment(input: MergeEnvironmentInput!): MergeEnvironment!
  duplicateProduct(input: DuplicateProductInput!): Product!
  createOneProduct(input: CreateOneProductInput!): Product!
  deleteOneProduct(input: DeleteOneProductInput!): ProductDeleteResponse!
  updateOneProduct(input: UpdateOneProductInput!): Product!
  createOnePlan(input: PlanCreateInput!): Plan!
  publishPlan(input: PackagePublishInput!): PublishPackageResult!
  triggerPlanSubscriptionMigration(input: TriggerSubscriptionMigrationInput!): TriggerSubscriptionMigrationResult!
  archivePlan(input: ArchivePlanInput!): Plan!

  """Set compatible package groups for a plan"""
  setCompatiblePackageGroups(input: SetPlanCompatiblePackageGroups!): Plan!
  removePlanDraft(input: DiscardPackageDraftInput!): String!
  createPlanDraft(id: String!): Plan!
  createEmptyPlanDraft(id: String!): Plan!
  updateOnePlan(input: PlanUpdateInput!): Plan!
  createOneAddon(input: AddonCreateInput!): Addon!
  removeAddonDraft(input: DiscardPackageDraftInput!): String!
  updateOneAddon(input: AddonUpdateInput!): Addon!
  createAddonDraft(id: String!): Addon!
  createEmptyAddonDraft(id: String!): Addon!

  """Archive an addon by id"""
  archiveAddon(input: AddonArchiveInput!): Addon!
  publishAddon(input: PackagePublishInput!): PublishPackageResult!
  setWidgetConfiguration(input: WidgetConfigurationUpdateInput!): String
  setPackagePricing(input: PackagePricingInput!): PackagePrice!
  createFeature(input: FeatureInput!): Feature!
  updateFeature(input: UpdateFeatureInput!): Feature!
  deleteFeature(input: DeleteFeatureInput!): Feature!
  archiveFeature(input: ArchiveFeatureInput!): Feature!
  deleteOneFeature(input: DeleteFeatureInput!): Feature!
  updateEntitlementsOrder(input: UpdatePackageEntitlementOrderInput!): [UpdateEntitlementsOrderDTO!]!
  grantPromotionalEntitlements(input: GrantPromotionalEntitlementsInput!): [PromotionalEntitlement!]!
  revokePromotionalEntitlement(input: RevokePromotionalEntitlementInput!): PromotionalEntitlement!
  reportEntitlementCheckRequested(entitlementCheckRequested: EntitlementCheckRequested!): Boolean!
  recalculateEntitlements(input: RecalculateEntitlementsInput!): RecalculateEntitlementsResult!
  createManyPackageEntitlements(input: CreateManyPackageEntitlementsInput!): [PackageEntitlement!]!
  updateOnePackageEntitlement(input: UpdateOnePackageEntitlementInput!): PackageEntitlement!
  deleteOnePackageEntitlement(input: DeleteOnePackageEntitlementInput!): PackageEntitlementDeleteResponse!
  createManyPromotionalEntitlements(input: CreateManyPromotionalEntitlementsInput!): [PromotionalEntitlement!]!
  updateOnePromotionalEntitlement(input: UpdateOnePromotionalEntitlementInput!): PromotionalEntitlement!
  deleteOnePromotionalEntitlement(input: DeleteOnePromotionalEntitlementInput!): PromotionalEntitlementDeleteResponse!
  createOneExperiment(input: CreateExperimentInput!): Experiment!
  updateOneExperiment(input: UpdateExperimentInput!): Experiment!
  startExperiment(input: StartExperimentInput!): String!
  stopExperiment(input: StopExperimentInput!): String!
  resyncIntegration(input: ResyncIntegrationInput!): ResyncIntegrationResult!
  triggerImportCatalog(input: ImportIntegrationCatalogInput!): AsyncTaskResult!
  triggerImportCustomers(input: ImportIntegrationCustomersInput!): AsyncTaskResult!
  createOrUpdateAwsMarketplaceProduct(input: CreateOrUpdateAwsMarketplaceProductInput!): Product!
  createOneCoupon(input: CreateCouponInput!): Coupon!
  updateOneCoupon(input: UpdateCouponInput!): Coupon!
  archiveOneCoupon(input: ArchiveCouponInput!): Coupon!
  createPackageGroup(input: CreatePackageGroup!): PackageGroup!
  editPackageGroup(input: EditPackageGroupDetailsInput!): PackageGroup!
  setPackageGroupAddons(input: SetPackageGroupAddons!): PackageGroup!
  archivePackageGroup(input: ArchivePackageGroup!): PackageGroup!
  updateOneEnvironment(input: UpdateOneEnvironmentInput!): Environment!
  createOneIntegration(input: CreateOneIntegrationInput!): Integration!
  updateOneIntegration(input: UpdateOneIntegrationInput!): Integration!
  deleteOneIntegration(input: DeleteOneIntegrationInput!): IntegrationDeleteResponse!
  setBasePlanOnPlan(input: SetBasePlanOnPlanInput!): Plan!
  addCompatibleAddonsToPlan(input: AddCompatibleAddonsToPlanInput!): Plan!
  setCompatibleAddonsOnPlan(input: SetCompatibleAddonsOnPlanInput!): Plan!
  removeBasePlanFromPlan(input: RemoveBasePlanFromPlanInput!): Plan!
  removeCompatibleAddonsFromPlan(input: RemoveCompatibleAddonsFromPlanInput!): Plan!
  deleteOnePrice(input: DeleteOnePriceInput!): PriceDeleteResponse!
  applySubscription(input: ApplySubscriptionInput!): ApplySubscription!
  previewSubscription(input: PreviewSubscriptionInput!): SubscriptionPreviewV2!
  createOneCustomer(input: CustomerInput!): Customer! @deprecated(reason: "Use 'provisionCustomer' instead to create both customer and subscription in single operation. See 'provisionCustomer' for more info.")
  provisionCustomer(input: ProvisionCustomerInput!): ProvisionedCustomer!
  archiveCustomer(input: ArchiveCustomerInput!): Customer!
  unarchiveCustomer(input: UnarchiveCustomerInput!): Customer!
  importCustomersBulk(input: ImportCustomerBulkInput!): String
  importOneCustomer(input: ImportCustomerInput!): Customer!
  updateOneCustomer(input: UpdateCustomerInput!): Customer!
  initAddStripeCustomerPaymentMethod(input: InitAddStripeCustomerPaymentMethodInput!): InitAddStripeCustomerPaymentMethod!
  preparePaymentMethodForm(input: PreparePaymentMethodFormInput!): PreparedPaymentMethodForm!
  attachCustomerPaymentMethod(input: AttachCustomerPaymentMethodInput!): Customer!
  detachCustomerPaymentMethod(input: DetachCustomerPaymentMethodInput!): Customer!
  setCouponOnCustomer(input: SetCouponOnCustomerInput!): Customer!
  setExperimentOnCustomer(input: SetExperimentOnCustomerInput!): Customer!
  removeCouponFromCustomer(input: RemoveCouponFromCustomerInput!): Customer!
  removeExperimentFromCustomer(input: RemoveExperimentFromCustomerInput!): Customer!
  setExperimentOnCustomerSubscription(input: SetExperimentOnCustomerSubscriptionInput!): CustomerSubscription!
  removeExperimentFromCustomerSubscription(input: RemoveExperimentFromCustomerSubscriptionInput!): CustomerSubscription!
  inviteMembers(input: InviteMembersInput!): MembersInviteResponse!
  registerMember: User!
  removeMember(memberId: String!): String!
  hideGettingStartedPage(memberId: String!): String!
  setAccessRoles(setAccessRolesInput: SetAccessRolesInput!): String
  createUsageMeasurement(usageMeasurement: UsageMeasurementCreateInput!): UsageMeasurementWithCurrentUsage! @deprecated(reason: "Deprecated query, use 'reportUsage' instead")
  reportUsage(input: ReportUsageInput!): UsageMeasurementWithCurrentUsage!
  reportUsageBulk(input: ReportUsageBulkInput!): [UsageMeasurementWithCurrentUsage!]!
  reportEvent(events: UsageEventsReportInput!): String
  createOneHook(input: CreateOneHookInput!): Hook!
  updateOneHook(input: UpdateOneHookInput!): Hook!
  deleteOneHook(input: DeleteOneHookInput!): HookDeleteResponse!
  purgeCustomerCache(input: ClearCustomerPersistentCacheInput!): String!
  syncTaxRates(input: SyncTaxRatesInput!): String
}

input UpdateUserInput {
  name: String!
  department: Department
}

input SubscriptionCancellationInput {
  subscriptionRefId: String!
  environmentId: String
  subscriptionCancellationTime: SubscriptionCancellationTime
  subscriptionCancellationAction: SubscriptionCancellationAction
  endDate: DateTime

  """
  If set, enables or disables prorating of credits on subscription cancellation.
  """
  prorate: Boolean
}

""""""
enum SubscriptionCancellationAction {
  DEFAULT
  REVOKE_ENTITLEMENTS
}

input SubscriptionInput {
  planId: String!
  billingPeriod: BillingPeriod
  priceUnitAmount: Float
  unitQuantity: Float = -1
  addons: [SubscriptionAddonInput!]
  billableFeatures: [BillableFeatureInput!]
  startDate: DateTime
  refId: String
  resourceId: String
  additionalMetaData: JSON
  awaitPaymentConfirmation: Boolean = true
  billingInformation: SubscriptionBillingInfo
  billingId: String
  subscriptionId: String
  promotionCode: String
  billingCountryCode: String
  subscriptionEntitlements: [SubscriptionEntitlementInput!]
  scheduleStrategy: ScheduleStrategy
  salesforceId: String

  """Budget configuration"""
  budget: BudgetConfigurationInput

  """The minimum spend configuration"""
  minimumSpend: SubscriptionMinimumSpendValueInput

  """Override the price of the subscription"""
  priceOverrides: [PriceOverrideInput!]

  """Subscription payment collection method"""
  paymentCollectionMethod: PaymentCollectionMethod = CHARGE

  """Coupon input"""
  appliedCoupon: SubscriptionCouponInput
  customerId: String!
  payingCustomerId: String
  crmId: String

  """Indicates the behavior of the subscription when the trial is expired."""
  trialEndBehavior: TrialEndBehavior
  isTrial: Boolean
  isOverridingTrialConfig: Boolean = false
  isCustomPriceSubscription: Boolean = false
  endDate: DateTime
  environmentId: String
}

input SubscriptionAddonInput {
  addonId: String!
  quantity: Int = 1
}

input BillableFeatureInput {
  featureId: String!
  quantity: Float!
}

input SubscriptionBillingInfo {
  taxRateIds: [String!]
  couponId: String
  taxPercentage: Float
  billingAddress: BillingAddress
  metadata: JSON
  chargeOnBehalfOfAccount: String
  isBackdated: Boolean = false
  isInvoicePaid: Boolean = false
  invoiceDaysUntilDue: Float
}

input BillingAddress {
  city: String
  country: String
  line1: String
  line2: String
  postalCode: String
  state: String
}

input SubscriptionEntitlementInput {
  description: String
  featureId: String!
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  resetPeriod: EntitlementResetPeriod
  yearlyResetPeriodConfiguration: YearlyResetPeriodConfigInput
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
}

"""Options for when a change for a paid subscription should take effect"""
enum ScheduleStrategy {
  """Schedule the change to the end of the billing period"""
  END_OF_BILLING_PERIOD

  """
  Schedule the change to the end of the billing month (for subscriptions whose billing period is larger then month)
  """
  END_OF_BILLING_MONTH

  """Apply the change immediately"""
  IMMEDIATE
}

"""Budget configuration input"""
input BudgetConfigurationInput {
  """The maximum spending limit"""
  limit: Float!

  """
  Indicates the behavior of the budget when the limit is exceeded. If true, the limit is a soft limit, if false, the limit is a hard limit. Default is false.
  """
  hasSoftLimit: Boolean!
}

"""Subscription minimum spend"""
input SubscriptionMinimumSpendValueInput {
  """The minimum spend"""
  minimum: MoneyInputDTO
}

input MoneyInputDTO {
  amount: Float!
  currency: Currency
}

input PriceOverrideInput {
  price: MoneyInputDTO

  """The number of units per block. Defaults to 1 unit."""
  blockSize: Float
  tiers: [PriceTierInput!]

  """The corresponding feature id of the price"""
  featureId: String

  """The corresponding addon id of the price"""
  addonId: String

  """Whether the price is a base charge"""
  baseCharge: Boolean
}

input PriceTierInput {
  upTo: Float
  unitPrice: MoneyInputDTO
  flatPrice: MoneyInputDTO
}

"""Subscription coupon input"""
input SubscriptionCouponInput {
  """Stigg coupon id"""
  couponId: String

  """Billing integration coupon id"""
  billingCouponId: String

  """Promotion code"""
  promotionCode: String

  """An inline discount"""
  discount: SubscriptionCouponDiscountInput

  """Coupon configuration input"""
  configuration: SubscriptionCouponConfigurationInput
}

"""Inline subscription coupon input"""
input SubscriptionCouponDiscountInput {
  """Name of the coupon that will be created"""
  name: String

  """Description of the coupon that will be created"""
  description: String

  """The duration in months for which the coupon remains active."""
  durationInMonths: Float

  """Discount percent off"""
  percentOff: Float

  """Discount flat fee amounts off"""
  amountsOff: [MoneyInputDTO!]
}

"""Subscription coupon configuration input"""
input SubscriptionCouponConfigurationInput {
  """The date to start the coupon from"""
  startDate: DateTime
}

input ProvisionSubscription {
  planId: String!
  billingPeriod: BillingPeriod
  priceUnitAmount: Float
  unitQuantity: Float = -1
  addons: [SubscriptionAddonInput!]
  billableFeatures: [BillableFeatureInput!]
  startDate: DateTime
  refId: String
  resourceId: String
  additionalMetaData: JSON
  awaitPaymentConfirmation: Boolean = true
  billingInformation: SubscriptionBillingInfo
  billingId: String
  subscriptionId: String
  promotionCode: String
  billingCountryCode: String
  subscriptionEntitlements: [SubscriptionEntitlementInput!]
  trialOverrideConfiguration: TrialOverrideConfigurationInput
  scheduleStrategy: ScheduleStrategy
  salesforceId: String

  """Budget configuration"""
  budget: BudgetConfigurationInput

  """The minimum spend configuration"""
  minimumSpend: SubscriptionMinimumSpendValueInput

  """Override the price of the subscription"""
  priceOverrides: [PriceOverrideInput!]

  """Subscription payment collection method"""
  paymentCollectionMethod: PaymentCollectionMethod = CHARGE

  """Coupon input"""
  appliedCoupon: SubscriptionCouponInput
  customerId: String!
  payingCustomerId: String
  skipTrial: Boolean = false
  checkoutOptions: CheckoutOptions
}

input TrialOverrideConfigurationInput {
  isTrial: Boolean!
  trialEndDate: DateTime

  """Indicates the behavior of the subscription when the trial is expired."""
  trialEndBehavior: TrialEndBehavior
}

input CheckoutOptions {
  successUrl: String!
  cancelUrl: String!
  allowPromoCodes: Boolean = false
  allowTaxIdCollection: Boolean = false
  collectBillingAddress: Boolean = false
  referenceId: String
  collectPhoneNumber: Boolean = false
}

input ProvisionSubscriptionInput {
  planId: String!
  billingPeriod: BillingPeriod
  priceUnitAmount: Float
  unitQuantity: Float = -1
  addons: [SubscriptionAddonInput!]
  billableFeatures: [BillableFeatureInput!]
  startDate: DateTime
  refId: String
  resourceId: String
  additionalMetaData: JSON
  awaitPaymentConfirmation: Boolean = true
  billingInformation: SubscriptionBillingInfo
  billingId: String
  subscriptionId: String
  promotionCode: String
  billingCountryCode: String
  subscriptionEntitlements: [SubscriptionEntitlementInput!]
  trialOverrideConfiguration: TrialOverrideConfigurationInput
  scheduleStrategy: ScheduleStrategy
  salesforceId: String

  """Budget configuration"""
  budget: BudgetConfigurationInput

  """The minimum spend configuration"""
  minimumSpend: SubscriptionMinimumSpendValueInput

  """Override the price of the subscription"""
  priceOverrides: [PriceOverrideInput!]

  """Subscription payment collection method"""
  paymentCollectionMethod: PaymentCollectionMethod = CHARGE

  """Coupon input"""
  appliedCoupon: SubscriptionCouponInput
  customerId: String!
  payingCustomerId: String
  skipTrial: Boolean = false
  checkoutOptions: CheckoutOptions
}

input ImportSubscriptionsBulkInput {
  subscriptions: [ImportSubscriptionInput!]!
  environmentId: String
}

input ImportSubscriptionInput {
  customerId: String!
  subscriptionId: String
  billingId: String
  salesforceId: String
  resourceId: String
  planId: String!
  billingPeriod: BillingPeriod
  unitQuantity: Float
  billableFeatures: [BillableFeatureInput!]
  subscriptionEntitlements: [SubscriptionEntitlementInput!]
  addons: [SubscriptionAddonInput!]
  startDate: DateTime
  endDate: DateTime

  """
  Indicates the last update of the subscription. In case there's already existing subscription that was updated after that date, it will skip import this subscription
  """
  updatedAt: DateTime
  additionalMetaData: JSON
}

input SubscriptionMigrationInput {
  subscriptionId: String!
  environmentId: String
  subscriptionMigrationTime: SubscriptionMigrationTime
}

"""
Set non immediate cancellation time (atm supported only for stripe integration)
"""
enum SubscriptionMigrationTime {
  END_OF_BILLING_PERIOD
  IMMEDIATE
}

input TransferSubscriptionInput {
  customerId: String!
  sourceResourceId: String!
  destinationResourceId: String!
}

"""The input for delegating a subscription to a customer"""
input DelegateSubscriptionToCustomerInput {
  """The environment ID of the subscription to delegate"""
  environmentId: String

  """The ID of the subscription to delegate"""
  subscriptionId: String!

  """
  The customer ID which will manage the subscription (the paying customer of the subscription will not change)
  """
  destinationCustomerId: String
}

"""The input for transferring a subscription to a resource"""
input TransferSubscriptionToResourceInput {
  """The environment ID of the subscription to transfer"""
  environmentId: String

  """The ID of the subscription to transfer"""
  subscriptionId: String!

  """The resource ID to transfer the subscription to"""
  destinationResourceId: String
}

"""Input for triggering the subscription billing month ends soon webhook"""
input TriggerSubscriptionBillingMonthEndsSoonWebhookInput {
  """The subscription reference id to trigger the webhook for"""
  subscriptionId: String!
}

"""Input for triggering an immediate usage charge for a subscription"""
input ChargeSubscriptionUsageInput {
  """The subscription reference id to charge usage for"""
  subscriptionId: String!

  """The end date until which to calculate the usage"""
  untilDate: DateTime

  """The id of the subscriptions environment"""
  environmentId: String
}

"""Input for triggering usage sync"""
input TriggerSubscriptionUsageSyncInput {
  """The customer id to trigger usage sync for"""
  customerId: String!

  """The environment id to trigger usage sync for"""
  environmentId: String

  """The resource id to trigger usage sync for"""
  resourceId: String
}

"""Input for triggering the subscription invoice as paid"""
input MarkInvoiceAsPaidInput {
  """Environment ID"""
  environmentId: String

  """The subscription entity id to trigger mark invoice as paid"""
  subscriptionId: String!
}

input UpdateSubscriptionInput {
  additionalMetaData: JSON
  environmentId: String
  unitQuantity: Float
  billableFeatures: [BillableFeatureInput!]
  refId: String
  subscriptionId: String
  addons: [SubscriptionAddonInput!]
  trialEndDate: DateTime
  promotionCode: String
  subscriptionEntitlements: [UpdateSubscriptionEntitlementInput!]
  billingPeriod: BillingPeriod
  awaitPaymentConfirmation: Boolean = true
  billingInformation: SubscriptionBillingInfo
  scheduleStrategy: ScheduleStrategy

  """Budget configuration"""
  budget: BudgetConfigurationInput

  """The minimum spend configuration"""
  minimumSpend: SubscriptionMinimumSpendValueInput

  """Override the price of the subscription"""
  priceOverrides: [PriceOverrideInput!]

  """Coupon input"""
  appliedCoupon: SubscriptionCouponInput
}

input UpdateSubscriptionEntitlementInput {
  id: String
  featureId: String
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  resetPeriod: EntitlementResetPeriod
  yearlyResetPeriodConfiguration: YearlyResetPeriodConfigInput
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
}

input EstimateSubscriptionInput {
  environmentId: String
  customerId: String!

  """The customer that will pay for the subscription"""
  payingCustomerId: String
  resourceId: String
  planId: String!
  billingPeriod: BillingPeriod
  billingCountryCode: String
  priceUnitAmount: Float
  unitQuantity: Float = -1
  billableFeatures: [BillableFeatureInput!]
  addons: [SubscriptionAddonInput!]
  startDate: DateTime
  billingInformation: SubscriptionBillingInfo
  promotionCode: String
  skipTrial: Boolean = false

  """Coupon input"""
  appliedCoupon: SubscriptionCouponInput

  """trial configuration to override the default values from plan if exists"""
  trialOverrideConfiguration: TrialOverrideConfigurationInput
}

input EstimateSubscriptionUpdateInput {
  environmentId: String
  subscriptionId: String!
  unitQuantity: Float
  billableFeatures: [BillableFeatureInput!]
  addons: [SubscriptionAddonInput!]
  promotionCode: String

  """Coupon input"""
  appliedCoupon: SubscriptionCouponInput
}

"""Input to preview the next invoice for a subscription"""
input PreviewNextInvoiceInput {
  """The environment id of the subscription to preview"""
  environmentId: String

  """The subscription id to preview"""
  subscriptionId: String!
}

input SubscriptionUpdateScheduleCancellationInput {
  subscriptionId: String!
  environmentId: String
  status: SubscriptionScheduleStatus = Scheduled
}

input UpdateAccountInput {
  displayName: String!
  timezone: String
  subscriptionBillingAnchor: BillingAnchor
  subscriptionProrationBehavior: ProrationBehavior
  defaultSSORoles: DefaultSSORolesInput
}

input DefaultSSORolesInput {
  """Account level access of the user"""
  accountRole: AccountAccessRole!

  """Environment level access of the user"""
  productionRole: EnvironmentAccessRole!

  """Environment level access of the user"""
  nonProductionRole: EnvironmentAccessRole!
}

input CreateOneEnvironmentInput {
  environment: CreateEnvironment!
  options: CreateEnvironmentOptions
}

input CreateEnvironment {
  id: String
  createdAt: DateTime
  displayName: String
  description: String
  slug: String
  provisionStatus: EnvironmentProvisionStatus
  hardenClientAccessEnabled: Boolean
  color: String
  type: EnvironmentType = DEVELOPMENT
}

input CreateEnvironmentOptions {
  createDefaultProduct: Boolean
}

input ArchiveEnvironmentInput {
  id: String
  slug: String
}

input UnarchiveEnvironmentInput {
  id: String
  slug: String
}

input ProvisionSandboxInput {
  displayName: String!
  billingModel: BillingModel!
}

"""Input type for mergeEnvironment mutation."""
input MergeEnvironmentInput {
  """
  The slug of the environment to copy from. If missing `sourceTemplate` will be used.
  """
  sourceEnvironmentSlug: String

  """
  The product catalog template to apply. Only relevant when `sourceEnvironmentSlug` is not passed.
  """
  sourceTemplate: JSON

  """
  The slug of the environment to merge into. Not passing this will create a new environment and requires passing `destinationEnvironmentName`.
  """
  destinationEnvironmentSlug: String

  """
  The name of the new environment. Only relevant when `destinationEnvironmentSlug` is not passed.
  """
  destinationEnvironmentName: String

  """
  How to migrate customers to newer plan version of updated plans. Default is not to migrate existing customers.
  """
  migrationType: PublishMigrationType

  """
  The type of the new environment. only relevant when `destinationEnvironmentSlug` is not passed.
  """
  destinationEnvironmentType: EnvironmentType

  """Merge configuration"""
  mergeConfiguration: EnvironmentMergeConfigurationInput
}

input DuplicateProductInput {
  sourceProductId: String!
  displayName: String
  refId: String!
  environmentId: String!
  description: String
}

input CreateOneProductInput {
  """The record to create"""
  product: ProductCreateInput!
}

input ProductCreateInput {
  description: String
  displayName: String
  refId: String!
  environmentId: String!
  multipleSubscriptions: Boolean = false
  additionalMetaData: JSON
}

input DeleteOneProductInput {
  """The id of the record to delete."""
  id: String!
}

input UpdateOneProductInput {
  """The id of the record to update"""
  id: String!

  """The update to apply."""
  update: ProductUpdateInput!
}

input ProductUpdateInput {
  description: String
  displayName: String
  productSettings: ProductSettingsInput

  """Auto cancellation rules"""
  autoCancellationRules: [AutoCancellationRuleInput!]

  """Usage reset cutoff rule"""
  usageResetCutoffRule: SubscriptionUpdateUsageResetCutoffRuleInput
  multipleSubscriptions: Boolean
  additionalMetaData: JSON
}

input ProductSettingsInput {
  subscriptionEndSetup: SubscriptionEndSetup!
  subscriptionCancellationTime: SubscriptionCancellationTime!
  downgradePlanId: String
  subscriptionStartSetup: SubscriptionStartSetup!
  subscriptionStartPlanId: String
  downgradeAtEndOfBillingPeriod: String
  prorateAtEndOfBillingPeriod: Boolean
}

"""The input of the auto cancellation rule."""
input AutoCancellationRuleInput {
  """The id of the source plan."""
  sourcePlanId: String!

  """The id of the target plan."""
  targetPlanId: String!
}

"""The input of the usage reset cutoff rule."""
input SubscriptionUpdateUsageResetCutoffRuleInput {
  """The behavior of the usage reset cutoff rule."""
  behavior: SubscriptionUpdateUsageCutoffBehavior!
}

input PlanCreateInput {
  displayName: String!
  description: String
  refId: String
  status: PackageStatus
  billingId: String
  environmentId: String
  productId: String!
  additionalMetaData: JSON
  hiddenFromWidgets: [WidgetType!]
  pricingType: PricingType
  awsMarketplacePlanDimension: String
  parentPlanId: String
}

input PackagePublishInput {
  id: ID!
  migrationType: PublishMigrationType!
}

input TriggerSubscriptionMigrationInput {
  refId: String!
  versionNumber: Float!
  environmentId: String!
}

input ArchivePlanInput {
  id: String!
  environmentId: String
}

"""Set plan compatible package groups input"""
input SetPlanCompatiblePackageGroups {
  """The id of the plan"""
  id: String!

  """The package groups with optional options"""
  packageGroups: [SetPlanCompatiblePackageGroup!]!

  """The environment id"""
  environmentId: String
}

"""Set plan compatible package group input"""
input SetPlanCompatiblePackageGroup {
  """The package group id"""
  packageGroupId: String!

  """The options for the package group"""
  options: SetPlanCompatiblePackageGroupOptions
}

"""Set plan compatible package group options input"""
input SetPlanCompatiblePackageGroupOptions {
  """Number of required items from packageGroup"""
  minItems: Float

  """Number of free items from packageGroup"""
  freeItems: Float
}

input DiscardPackageDraftInput {
  refId: String!
  environmentId: String!
}

input PlanUpdateInput {
  id: String!
  displayName: String
  description: String
  status: PackageStatus
  billingId: String
  parentPlanId: String
  defaultTrialConfig: DefaultTrialConfigInputDTO
  additionalMetaData: JSON
  hiddenFromWidgets: [WidgetType!]

  """The minimum spend configuration per each billing period"""
  minimumSpend: [MinimumSpendInput!]
}

input DefaultTrialConfigInputDTO {
  units: TrialPeriodUnits
  duration: Float

  """Budget configuration"""
  budget: BudgetConfigurationInput

  """Trial end behavior"""
  trialEndBehavior: TrialEndBehavior
}

"""Minimum spend input"""
input MinimumSpendInput {
  """The billing period of minimum spend"""
  billingPeriod: BillingPeriod!

  """The minimum spend value"""
  minimum: MoneyInputDTO!
}

input AddonCreateInput {
  displayName: String!
  description: String
  refId: String
  status: PackageStatus
  billingId: String
  environmentId: String
  productId: String!
  additionalMetaData: JSON
  hiddenFromWidgets: [WidgetType!]
  pricingType: PricingType
  awsMarketplacePlanDimension: String

  """The maximum quantity of this addon that can be added to a subscription"""
  maxQuantity: Float

  """List of addon ids this addon should be dependant on"""
  dependencies: [String!]
}

input AddonUpdateInput {
  id: String!
  displayName: String
  description: String
  status: PackageStatus
  billingId: String
  additionalMetaData: JSON
  hiddenFromWidgets: [WidgetType!]

  """The maximum quantity of this addon that can be added to a subscription"""
  maxQuantity: Float

  """List of addon ids this addon should be dependant on"""
  dependencies: [String!]
}

"""Archive addon input"""
input AddonArchiveInput {
  """Addon id"""
  refId: String!

  """Environment id"""
  environmentId: String
}

input WidgetConfigurationUpdateInput {
  environmentId: String
  paywallConfiguration: PaywallConfigurationInput
  customerPortalConfiguration: CustomerPortalConfigurationInput
  checkoutConfiguration: CheckoutConfigurationInput
}

input PaywallConfigurationInput {
  palette: PaywallColorsPaletteInput
  typography: TypographyConfigurationInput
  layout: PaywallLayoutConfigurationInput
  customCss: String
}

input PaywallColorsPaletteInput {
  primary: String
  textColor: String
  backgroundColor: String
  borderColor: String
  currentPlanBackground: String
}

input TypographyConfigurationInput {
  fontFamily: String
  h1: FontVariantInput
  h2: FontVariantInput
  h3: FontVariantInput
  body: FontVariantInput
}

input FontVariantInput {
  fontSize: Float
  fontWeight: FontWeight
}

input PaywallLayoutConfigurationInput {
  alignment: Alignment
  planWidth: Float
  planMargin: Float
  planPadding: Float
}

input CustomerPortalConfigurationInput {
  palette: CustomerPortalColorsPaletteInput
  typography: TypographyConfigurationInput
  customCss: String
}

input CustomerPortalColorsPaletteInput {
  primary: String
  textColor: String
  backgroundColor: String
  borderColor: String
  currentPlanBackground: String
  iconsColor: String
  paywallBackgroundColor: String
}

input CheckoutConfigurationInput {
  palette: CheckoutPaletteInput
  typography: TypographyConfigurationInput
  customCss: String
  content: CheckoutContentInput
}

input CheckoutPaletteInput {
  primary: String
  textColor: String
  backgroundColor: String
  borderColor: String
  summaryBackgroundColor: String
}

input CheckoutContentInput {
  collectPhoneNumber: Boolean
}

input PackagePricingInput {
  pricingType: PricingType!
  environmentId: String!
  packageId: String!
  pricingModel: PricingModelCreateInput
  pricingModels: [PricingModelCreateInput!]
  overagePricingModels: [OveragePricingModelCreateInput!]
  overageBillingPeriod: OverageBillingPeriod

  """The minimum spend configuration per each billing period"""
  minimumSpend: [MinimumSpendInput!]
}

input PricingModelCreateInput {
  billingModel: BillingModel!
  billingCadence: BillingCadence = RECURRING
  pricePeriods: [PricePeriodInput!]!
  featureId: String
  tiersMode: TiersMode
  minUnitQuantity: Float
  maxUnitQuantity: Float
  resetPeriod: EntitlementResetPeriod
  yearlyResetPeriodConfiguration: YearlyResetPeriodConfigInput
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
}

input PricePeriodInput {
  billingPeriod: BillingPeriod!
  billingCountryCode: String
  price: MoneyInputDTO

  """The number of units per block. Defaults to 1 unit."""
  blockSize: Float
  tiers: [PriceTierInput!]
}

input OveragePricingModelCreateInput {
  billingModel: BillingModel!
  billingCadence: BillingCadence = RECURRING
  pricePeriods: [PricePeriodInput!]!
  featureId: String
  entitlement: OverageEntitlementCreateInput
}

input OverageEntitlementCreateInput {
  description: String
  featureId: String!
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  isCustom: Boolean
  resetPeriod: EntitlementResetPeriod
  yearlyResetPeriodConfiguration: YearlyResetPeriodConfigInput
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
  order: Float
  hiddenFromWidgets: [WidgetType!]
  displayNameOverride: String

  """The behavior of the entitlement"""
  behavior: EntitlementBehavior = Increment
}

input FeatureInput {
  displayName: String!
  refId: String!
  featureUnits: String
  featureUnitsPlural: String
  description: String
  featureType: FeatureType!
  meterType: MeterType
  featureStatus: FeatureStatus
  meter: CreateMeter
  environmentId: String!
  additionalMetaData: JSON

  """Unit transformation to be applied to the reported usage"""
  unitTransformation: UnitTransformationInput
}

input CreateMeter {
  filters: [MeterFilterDefinitionInput!]!
  aggregation: MeterAggregation!
}

"""Input for unit transformation to be applied to the reported usage"""
input UnitTransformationInput {
  """After division, either round the result up or down"""
  round: UnitTransformationRound = UP

  """Divide usage by this number"""
  divide: Int!

  """Singular feature units after the transformation"""
  featureUnits: String

  """Plural feature units after the transformation"""
  featureUnitsPlural: String
}

input UpdateFeatureInput {
  featureUnits: String
  featureUnitsPlural: String
  description: String
  meter: CreateMeter
  environmentId: String!

  """Unit transformation to be applied to the reported usage"""
  unitTransformation: UnitTransformationInput
  displayName: String
  refId: String!
  additionalMetaData: JSON
}

input DeleteFeatureInput {
  id: String!
  environmentId: String
}

input ArchiveFeatureInput {
  id: String!
  environmentId: String
}

input UpdatePackageEntitlementOrderInput {
  environmentId: String
  packageId: String!
  entitlements: [UpdatePackageEntitlementOrderItemInput!]!
}

input UpdatePackageEntitlementOrderItemInput {
  id: String!
  order: Float
}

input GrantPromotionalEntitlementsInput {
  promotionalEntitlements: [GrantPromotionalEntitlementInput!]!
  customerId: String!
  environmentId: String
}

input GrantPromotionalEntitlementInput {
  featureId: String!
  usageLimit: Float
  hasSoftLimit: Boolean
  hasUnlimitedUsage: Boolean
  customEndDate: DateTime
  period: PromotionalEntitlementPeriod!
  isVisible: Boolean
  yearlyResetPeriodConfiguration: YearlyResetPeriodConfigInput
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
  resetPeriod: EntitlementResetPeriod
}

input RevokePromotionalEntitlementInput {
  customerId: String!
  featureId: String!
  environmentId: String
}

input EntitlementCheckRequested {
  customerId: String!
  resourceId: String
  featureId: String!
  environmentId: String
  requestedUsage: Float
  entitlementCheckResult: EntitlementCheckResult!
}

input EntitlementCheckResult {
  hasAccess: Boolean!
  accessDeniedReason: AccessDeniedReason
  currentUsage: Float
  requestedUsage: Float
  usageLimit: Float
  hasUnlimitedUsage: Boolean = false
  hasSoftLimit: Boolean = false
  nextResetDate: DateTime
  resetPeriod: EntitlementResetPeriod
  yearlyResetPeriodConfiguration: YearlyResetPeriodConfigInput
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
}

input RecalculateEntitlementsInput {
  environmentId: String!
  customerIds: [String!]
  forAllCustomers: Boolean = false
  sideEffectsOptions: RecalculateEntitlementsSideEffectsOptionsInput
}

input RecalculateEntitlementsSideEffectsOptionsInput {
  skipWriteToEventLog: Boolean = false
  skipWriteToDataCatalog: Boolean = false
  skipWriteToCache: Boolean = false
  skipPublishToSubscribers: Boolean = false
}

input CreateManyPackageEntitlementsInput {
  """Array of records to create"""
  packageEntitlements: [PackageEntitlementInput!]!
}

input PackageEntitlementInput {
  description: String
  featureId: String!
  packageId: String!
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  isCustom: Boolean
  resetPeriod: EntitlementResetPeriod
  yearlyResetPeriodConfiguration: YearlyResetPeriodConfigInput
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
  environmentId: String!
  order: Float
  hiddenFromWidgets: [WidgetType!]
  displayNameOverride: String

  """The behavior of the entitlement"""
  behavior: EntitlementBehavior = Increment
}

input UpdateOnePackageEntitlementInput {
  """The id of the record to update"""
  id: String!

  """The update to apply."""
  update: PackageEntitlementUpdateInput!
}

input PackageEntitlementUpdateInput {
  description: String
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  isCustom: Boolean
  resetPeriod: EntitlementResetPeriod
  yearlyResetPeriodConfiguration: YearlyResetPeriodConfigInput
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
  order: Float
  hiddenFromWidgets: [WidgetType!]
  displayNameOverride: String

  """The behavior of the entitlement"""
  behavior: EntitlementBehavior
}

input DeleteOnePackageEntitlementInput {
  """The id of the record to delete."""
  id: String!
}

input CreateManyPromotionalEntitlementsInput {
  """Array of records to create"""
  promotionalEntitlements: [PromotionalEntitlementInput!]!
}

input PromotionalEntitlementInput {
  description: String
  featureId: String!
  customerId: String!
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  endDate: DateTime
  period: PromotionalEntitlementPeriod!
  isVisible: Boolean!
  yearlyResetPeriodConfiguration: YearlyResetPeriodConfigInput
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
  resetPeriod: EntitlementResetPeriod
  environmentId: String!
}

input UpdateOnePromotionalEntitlementInput {
  """The id of the record to update"""
  id: String!

  """The update to apply."""
  update: PromotionalEntitlementUpdateInput!
}

input PromotionalEntitlementUpdateInput {
  description: String
  usageLimit: Float
  hasUnlimitedUsage: Boolean
  hasSoftLimit: Boolean
  endDate: DateTime
  period: PromotionalEntitlementPeriod!
  isVisible: Boolean!
  monthlyResetPeriodConfiguration: MonthlyResetPeriodConfigInput
  weeklyResetPeriodConfiguration: WeeklyResetPeriodConfigInput
  resetPeriod: EntitlementResetPeriod
}

input DeleteOnePromotionalEntitlementInput {
  """The id of the record to delete."""
  id: String!
}

input CreateExperimentInput {
  environmentId: String
  description: String
  name: String!
  productId: String!
  variantPercentage: Float!
  controlGroupName: String!
  variantGroupName: String!
  productSettings: ProductSettingsInput
}

input UpdateExperimentInput {
  environmentId: String
  refId: String!
  description: String
  name: String
  productId: String
  variantPercentage: Float
  controlGroupName: String
  variantGroupName: String
  productSettings: ProductSettingsInput
}

input StartExperimentInput {
  environmentId: String
  refId: String!
}

input StopExperimentInput {
  environmentId: String
  refId: String!
}

input ResyncIntegrationInput {
  """ID of the environment to re-sync"""
  environmentId: String!

  """Type of integration to re-sync"""
  vendorIdentifier: VendorIdentifier!

  """ID of the integration to re-sync"""
  integrationId: String

  """Allow skipping entitlement recalculation"""
  recalculateEntitlements: Boolean
}

input ImportIntegrationCatalogInput {
  environmentId: String!
  vendorIdentifier: VendorIdentifier!
  productId: String!
  selectedAddonBillingIds: [String!]!
  entitySelectionMode: EntitySelectionMode!
  plansSelectionWhitelist: [String!]
  plansSelectionBlacklist: [String!]
  billingModel: BillingModel
  featureUnitName: String
  featureUnitPluralName: String
}

enum EntitySelectionMode {
  BLACK_LIST
  WHITE_LIST
}

input ImportIntegrationCustomersInput {
  environmentId: String!
  vendorIdentifier: VendorIdentifier!
  productId: String!
  entitySelectionMode: EntitySelectionMode!
  customersSelectionWhitelist: [String!]
  customersSelectionBlacklist: [String!]
}

input CreateOrUpdateAwsMarketplaceProductInput {
  description: String
  displayName: String
  productSettings: ProductSettingsInput

  """Auto cancellation rules"""
  autoCancellationRules: [AutoCancellationRuleInput!]

  """Usage reset cutoff rule"""
  usageResetCutoffRule: SubscriptionUpdateUsageResetCutoffRuleInput
  multipleSubscriptions: Boolean
  additionalMetaData: JSON
  refId: String
  environmentId: String
  productId: String
  awsProductId: String
  awsDimensionsMapping: [DimensionsMappingInput!]!
}

input DimensionsMappingInput {
  key: String!
  planName: String!
  planRefId: String!
}

input CreateCouponInput {
  environmentId: String
  refId: String!
  description: String
  name: String!
  type: CouponType
  discountValue: Float

  """Discount percent off"""
  percentOff: Float

  """Discount flat fee amounts off"""
  amountsOff: [MoneyInputDTO!]
  additionalMetaData: JSON

  """The duration in months for which the coupon remains active."""
  durationInMonths: Float
}

input UpdateCouponInput {
  refId: String!
  description: String
  environmentId: String
  name: String!
  additionalMetaData: JSON
}

input ArchiveCouponInput {
  refId: String!
  environmentId: String
}

"""The input type for creating an package group"""
input CreatePackageGroup {
  """The environment id to create the package group in"""
  environmentId: String

  """The display name of the package group"""
  displayName: String!

  """The description of the package group"""
  description: String

  """The id of the product"""
  productId: String!

  """The id of the package group"""
  packageGroupId: String!
}

"""The input type for editing package group details"""
input EditPackageGroupDetailsInput {
  """The environment id of the package group to be edited"""
  environmentId: String

  """The display name of the package group"""
  displayName: String!

  """The description of the package group"""
  description: String

  """The id of the package group"""
  packageGroupId: String!
}

"""The input type for setting the addons of an package group"""
input SetPackageGroupAddons {
  """The environment id to set the addons of the package group in"""
  environmentId: String

  """The id of the package group"""
  packageGroupId: String!

  """The addons to set on the package group"""
  addons: [String!]!
}

"""The input type for archiving package group"""
input ArchivePackageGroup {
  """The id of the package group"""
  packageGroupId: String!

  """The environment id to get the package group in"""
  environmentId: String!
}

input UpdateOneEnvironmentInput {
  """The id of the record to update"""
  id: String!

  """The update to apply."""
  update: EnvironmentInput!
}

input EnvironmentInput {
  displayName: String
  description: String
  color: String
  provisionStatus: EnvironmentProvisionStatus
  hardenClientAccessEnabled: Boolean
}

input CreateOneIntegrationInput {
  """The record to create"""
  integration: CreateIntegrationInput!
}

input CreateIntegrationInput {
  environmentId: String!
  vendorIdentifier: VendorIdentifier!

  """Whether the integration is the default integration"""
  isDefault: Boolean

  """The reference ID for the integration"""
  integrationId: String
  zuoraCredentials: ZuoraCredentialsInput
  stripeCredentials: StripeCredentialsInput
  hubspotCredentials: HubspotCredentialsInput
  awsMarketplaceCredentials: AwsMarketplaceCredentialsInput
  snowflakeCredentials: SnowflakeCredentialsInput
  salesforceCredentials: SalesforceCredentialsInput
  bigQueryCredentials: BigQueryCredentialsInput
  auth0Credentials: Auth0CredentialsInput
  openFGACredentials: OpenFGACredentialsInput
}

input ZuoraCredentialsInput {
  baseUrl: String!
  clientId: String!
  clientSecret: String!
  stripePublishableKey: String
  stripeSecretKey: String

  """The ID of the payment page to use"""
  paymentPageId: String
}

input StripeCredentialsInput {
  authorizationCode: String!
  isTestMode: Boolean!
  accountId: String
  isTaxEnabled: Boolean = false
}

input HubspotCredentialsInput {
  authorizationCode: String!
  refreshToken: String
}

input AwsMarketplaceCredentialsInput {
  awsRoleArn: String!
}

input SnowflakeCredentialsInput {
  host: String!
  database: String!
  schemaName: String!
  role: String!
  warehouse: String!
  username: String!
  password: String!
}

input SalesforceCredentialsInput {
  domain: String
}

input BigQueryCredentialsInput {
  projectId: String!
  datasetLocation: String!
  datasetId: String!
  hmacKeyAccessId: String!
  hmacKeySecret: String!
  gcsBucketName: String!
  gcsBucketPath: String!
  credentialsJson: String!
}

input Auth0CredentialsInput {
  clientDomain: String!
  clientId: String!
  clientSecret: String!
  applicationId: String!
  applicationName: String!
  applicationType: Auth0ApplicationType!
  individualSubscriptionStartSetup: SubscriptionStartSetup
  individualInitialPlanId: String
  organizationSubscriptionStartSetup: SubscriptionStartSetup
  organizationInitialPlanId: String
}

input OpenFGACredentialsInput {
  apiUrl: String!
  apiAudience: String!
  apiTokenIssuer: String!
  clientId: String!
  clientSecret: String!
  storeId: String
}

input UpdateOneIntegrationInput {
  """The id of the record to update"""
  id: String!

  """The update to apply."""
  update: UpdateIntegrationInput!
}

input UpdateIntegrationInput {
  vendorIdentifier: VendorIdentifier!

  """Whether the integration is the default integration"""
  isDefault: Boolean

  """The reference ID for the integration"""
  integrationId: String
  zuoraCredentials: ZuoraCredentialsInput
  auth0Credentials: Auth0CredentialsInput
  stripeCredentials: UpdateStripeCredentialsInput

  """Salesforce integration configuration"""
  salesforceCredentials: SalesforceCredentialsInput
  openFGACredentials: OpenFGACredentialsInput
}

input UpdateStripeCredentialsInput {
  isTaxEnabled: Boolean
}

input DeleteOneIntegrationInput {
  """The id of the record to delete."""
  id: String!
}

input SetBasePlanOnPlanInput {
  """The id of the record."""
  id: String!

  """The id of relation."""
  relationId: String!
}

input AddCompatibleAddonsToPlanInput {
  """The id of the record."""
  id: String!

  """The ids of the relations."""
  relationIds: [String!]!
}

input SetCompatibleAddonsOnPlanInput {
  """The id of the record."""
  id: String!

  """The ids of the relations."""
  relationIds: [String!]!
}

input RemoveBasePlanFromPlanInput {
  """The id of the record."""
  id: String!

  """The id of relation."""
  relationId: String!
}

input RemoveCompatibleAddonsFromPlanInput {
  """The id of the record."""
  id: String!

  """The ids of the relations."""
  relationIds: [String!]!
}

input DeleteOnePriceInput {
  """The id of the record to delete."""
  id: String!
}

input ApplySubscriptionInput {
  planId: String!
  billingPeriod: BillingPeriod
  unitQuantity: Float = -1
  addons: [SubscriptionAddonInput!]
  billableFeatures: [BillableFeatureInput!]
  startDate: DateTime
  resourceId: String
  additionalMetaData: JSON
  awaitPaymentConfirmation: Boolean = true
  billingInformation: SubscriptionBillingInfo
  billingId: String
  promotionCode: String
  billingCountryCode: String
  subscriptionEntitlements: [SubscriptionEntitlementInput!]
  trialOverrideConfiguration: TrialOverrideConfigurationInput
  scheduleStrategy: ScheduleStrategy
  salesforceId: String

  """Budget configuration"""
  budget: BudgetConfigurationInput

  """The minimum spend configuration"""
  minimumSpend: SubscriptionMinimumSpendValueInput

  """Override the price of the subscription"""
  priceOverrides: [PriceOverrideInput!]

  """Subscription payment collection method"""
  paymentCollectionMethod: PaymentCollectionMethod = CHARGE

  """Coupon input"""
  appliedCoupon: SubscriptionCouponInput
  customerId: String!
  payingCustomerId: String
  skipTrial: Boolean = false
  paymentMethodId: String
}

input PreviewSubscriptionInput {
  environmentId: String
  customerId: String!

  """The customer that will pay for the subscription"""
  payingCustomerId: String
  resourceId: String
  planId: String!
  billingPeriod: BillingPeriod
  billingCountryCode: String
  unitQuantity: Float = -1
  billableFeatures: [BillableFeatureInput!]
  addons: [SubscriptionAddonInput!]
  startDate: DateTime
  billingInformation: SubscriptionBillingInfo
  promotionCode: String
  scheduleStrategy: ScheduleStrategy

  """Coupon input"""
  appliedCoupon: SubscriptionCouponInput

  """trial configuration to override the default values from plan if exists"""
  trialOverrideConfiguration: TrialOverrideConfigurationInput
}

input CustomerInput {
  name: String
  email: String
  refId: String
  customerId: String
  environmentId: String
  billingId: String
  awsMarketplaceCustomerId: String
  salesforceId: String
  crmId: String
  couponRefId: String
  billingInformation: CustomerBillingInfo
  additionalMetaData: JSON
  shouldSyncFree: Boolean = false
  createdAt: DateTime
}

input CustomerBillingInfo {
  billingAddress: Address
  shippingAddress: Address
  currency: Currency
  taxIds: [TaxExempt!]
  invoiceCustomFields: JSON
  paymentMethodId: String
  timezone: String
  language: String
  customerName: String
  metadata: JSON
}

input Address {
  country: String
  state: String
  addressLine1: String
  addressLine2: String
  city: String
  postalCode: String
  phoneNumber: String
}

input TaxExempt {
  type: String!
  value: String!
}

input ProvisionCustomerInput {
  name: String
  email: String
  refId: String
  customerId: String
  environmentId: String
  billingId: String
  awsMarketplaceCustomerId: String
  salesforceId: String
  crmId: String
  couponRefId: String
  billingInformation: CustomerBillingInfo
  additionalMetaData: JSON
  shouldSyncFree: Boolean = false
  createdAt: DateTime
  subscriptionParams: ProvisionCustomerSubscriptionInput
  excludeFromExperiment: Boolean = false
}

input ProvisionCustomerSubscriptionInput {
  planId: String!
  billingPeriod: BillingPeriod
  priceUnitAmount: Float
  unitQuantity: Float = -1
  addons: [SubscriptionAddonInput!]
  billableFeatures: [BillableFeatureInput!]
  startDate: DateTime
  refId: String
  resourceId: String
  additionalMetaData: JSON
  awaitPaymentConfirmation: Boolean = true
  billingInformation: SubscriptionBillingInfo
  billingId: String
  subscriptionId: String
  promotionCode: String
  billingCountryCode: String
  subscriptionEntitlements: [SubscriptionEntitlementInput!]
  trialOverrideConfiguration: TrialOverrideConfigurationInput
  salesforceId: String

  """Budget configuration"""
  budget: BudgetConfigurationInput

  """The minimum spend configuration"""
  minimumSpend: SubscriptionMinimumSpendValueInput

  """Override the price of the subscription"""
  priceOverrides: [PriceOverrideInput!]

  """Subscription payment collection method"""
  paymentCollectionMethod: PaymentCollectionMethod = CHARGE

  """Coupon input"""
  appliedCoupon: SubscriptionCouponInput
}

input ArchiveCustomerInput {
  customerId: String!
  environmentId: String
}

input UnarchiveCustomerInput {
  customerId: String!
  environmentId: String
}

input ImportCustomerBulkInput {
  customers: [ImportCustomerInput!]!
  environmentId: String
}

input ImportCustomerInput {
  name: String
  email: String
  refId: String
  customerId: String
  environmentId: String
  billingId: String
  salesforceId: String
  paymentMethodId: String

  """
  Indicates the last update of the customer. In case there's already existing customer that was updated after that date, it will skip import this customer
  """
  updatedAt: DateTime
  additionalMetaData: JSON
}

input UpdateCustomerInput {
  refId: String
  customerId: String
  name: String
  email: String
  environmentId: String
  billingId: String
  crmId: String
  couponRefId: String
  billingInformation: CustomerBillingInfo
  additionalMetaData: JSON
  shouldWaitSync: Boolean = false
  awsMarketplaceCustomerId: String
  salesforceId: String
}

input InitAddStripeCustomerPaymentMethodInput {
  customerRefId: String!
  environmentId: String
}

input PreparePaymentMethodFormInput {
  customerId: String!
  environmentId: String
}

input AttachCustomerPaymentMethodInput {
  refId: String
  customerId: String
  environmentId: String
  vendorIdentifier: VendorIdentifier!
  paymentMethodId: String!
}

input DetachCustomerPaymentMethodInput {
  customerId: String!
  environmentId: String
}

input SetCouponOnCustomerInput {
  """The id of the record."""
  id: String!

  """The id of relation."""
  relationId: String!
}

input SetExperimentOnCustomerInput {
  """The id of the record."""
  id: String!

  """The id of relation."""
  relationId: String!
}

input RemoveCouponFromCustomerInput {
  """The id of the record."""
  id: String!

  """The id of relation."""
  relationId: String!
}

input RemoveExperimentFromCustomerInput {
  """The id of the record."""
  id: String!

  """The id of relation."""
  relationId: String!
}

input SetExperimentOnCustomerSubscriptionInput {
  """The id of the record."""
  id: String!

  """The id of relation."""
  relationId: String!
}

input RemoveExperimentFromCustomerSubscriptionInput {
  """The id of the record."""
  id: String!

  """The id of relation."""
  relationId: String!
}

input InviteMembersInput {
  """List of emails to invite"""
  invites: [String!]!

  """Account level access of the user, defaults to member role"""
  accountRole: AccountAccessRole

  """Environment level access of the user, defaults to read-only role"""
  productionRole: EnvironmentAccessRole

  """Environment level access of the user, defaults to read-only role"""
  nonProductionRole: EnvironmentAccessRole
}

input SetAccessRolesInput {
  """The id of the user associated with this member"""
  userId: String!

  """Account level access of the user"""
  accountRole: AccountAccessRole!

  """Environment level access of the user"""
  productionRole: EnvironmentAccessRole!

  """Environment level access of the user"""
  nonProductionRole: EnvironmentAccessRole!
}

input UsageMeasurementCreateInput {
  value: Float!
  featureId: String!
  customerId: String!
  resourceId: String
  createdAt: DateTime
  updateBehavior: UsageUpdateBehavior = DELTA
  dimensions: JSON
  environmentId: String
}

enum UsageUpdateBehavior {
  DELTA
  SET
}

input ReportUsageInput {
  value: Float!
  featureId: String!
  customerId: String!
  resourceId: String
  createdAt: DateTime
  updateBehavior: UsageUpdateBehavior = DELTA
  dimensions: JSON
  environmentId: String
}

input ReportUsageBulkInput {
  environmentId: String
  usages: [ReportUsageBaseInput!]!
}

input ReportUsageBaseInput {
  value: Float!
  featureId: String!
  customerId: String!
  resourceId: String
  createdAt: DateTime
  updateBehavior: UsageUpdateBehavior = DELTA
  dimensions: JSON
}

input UsageEventsReportInput {
  environmentId: String
  usageEvents: [UsageEventReportInput!]!
}

input UsageEventReportInput {
  eventName: String!
  customerId: String!
  resourceId: String
  timestamp: DateTime
  idempotencyKey: String!
  dimensions: JSON
}

input CreateOneHookInput {
  """The record to create"""
  hook: CreateHook!
}

input CreateHook {
  id: String
  description: String
  secretKey: String
  endpoint: String
  status: HookStatus
  createdAt: DateTime
  environmentId: String
  eventLogTypes: [EventLogType!]

  """A JSON containing the configuration for each event log type"""
  configuration: JSON
}

input UpdateOneHookInput {
  """The id of the record to update"""
  id: String!

  """The update to apply."""
  update: UpdateHook!
}

input UpdateHook {
  id: String
  description: String
  secretKey: String
  endpoint: String
  status: HookStatus
  createdAt: DateTime
  environmentId: String
  eventLogTypes: [EventLogType!]

  """A JSON containing the configuration for each event log type"""
  configuration: JSON
}

input DeleteOneHookInput {
  """The id of the record to delete."""
  id: String!
}

input ClearCustomerPersistentCacheInput {
  customerId: String!
  resourceId: String
  environmentId: String
}

input SyncTaxRatesInput {
  environmentId: String
}

type Subscription {
  packagePublished: PackagePublished!
  entitlementsUpdated: EntitlementsUpdated!
  usageUpdated: UsageUpdated!
}
